{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport process from 'node:process';\nimport { Buffer } from 'node:buffer';\nimport { Duplex } from 'node:stream';\nimport { URL, URLSearchParams } from 'node:url';\nimport http, { ServerResponse } from 'node:http';\nimport timer from '@szmarczak/http-timer';\nimport CacheableRequest, { CacheError as CacheableCacheError } from 'cacheable-request';\nimport decompressResponse from 'decompress-response';\nimport is from '@sindresorhus/is';\nimport { buffer as getBuffer } from 'get-stream';\nimport { FormDataEncoder, isFormData as isFormDataLike } from 'form-data-encoder';\nimport getBodySize from './utils/get-body-size.js';\nimport isFormData from './utils/is-form-data.js';\nimport proxyEvents from './utils/proxy-events.js';\nimport timedOut, { TimeoutError as TimedOutTimeoutError } from './timed-out.js';\nimport urlToOptions from './utils/url-to-options.js';\nimport WeakableMap from './utils/weakable-map.js';\nimport calculateRetryDelay from './calculate-retry-delay.js';\nimport Options from './options.js';\nimport { isResponseOk } from './response.js';\nimport isClientRequest from './utils/is-client-request.js';\nimport isUnixSocketURL from './utils/is-unix-socket-url.js';\nimport { RequestError, ReadError, MaxRedirectsError, HTTPError, TimeoutError, UploadError, CacheError, AbortError } from './errors.js';\nconst supportsBrotli = is.string(process.versions.brotli);\nconst methodsWithoutBody = new Set(['GET', 'HEAD']);\nconst cacheableStore = new WeakableMap();\nconst redirectCodes = new Set([300, 301, 302, 303, 304, 307, 308]);\nconst proxiedRequestEvents = ['socket', 'connect', 'continue', 'information', 'upgrade'];\n\nconst noop = () => {};\n\nexport default class Request extends Duplex {\n  constructor(url, options, defaults) {\n    super({\n      // Don't destroy immediately, as the error may be emitted on unsuccessful retry\n      autoDestroy: false,\n      // It needs to be zero because we're just proxying the data to another stream\n      highWaterMark: 0\n    }); // @ts-expect-error - Ignoring for now.\n\n    Object.defineProperty(this, 'constructor', {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_noPipe\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    }); // @ts-expect-error https://github.com/microsoft/TypeScript/issues/9568\n\n    Object.defineProperty(this, \"options\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"response\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"requestUrl\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"redirectUrls\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"retryCount\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_stopRetry\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_downloadedSize\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_uploadedSize\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_stopReading\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_pipedServerResponses\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_request\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_responseSize\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_bodySize\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_unproxyEvents\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_isFromCache\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_cannotHaveBody\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_triggerRead\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_cancelTimeouts\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_removeListeners\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_nativeResponse\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_flushed\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_aborted\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    }); // We need this because `this._request` if `undefined` when using cache\n\n    Object.defineProperty(this, \"_requestInitialized\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this._downloadedSize = 0;\n    this._uploadedSize = 0;\n    this._stopReading = false;\n    this._pipedServerResponses = new Set();\n    this._cannotHaveBody = false;\n    this._unproxyEvents = noop;\n    this._triggerRead = false;\n    this._cancelTimeouts = noop;\n    this._removeListeners = noop;\n    this._jobs = [];\n    this._flushed = false;\n    this._requestInitialized = false;\n    this._aborted = false;\n    this.redirectUrls = [];\n    this.retryCount = 0;\n    this._stopRetry = noop;\n    this.on('pipe', source => {\n      if (source.headers) {\n        Object.assign(this.options.headers, source.headers);\n      }\n    });\n    this.on('newListener', event => {\n      if (event === 'retry' && this.listenerCount('retry') > 0) {\n        throw new Error('A retry listener has been attached already.');\n      }\n    });\n\n    try {\n      this.options = new Options(url, options, defaults);\n\n      if (!this.options.url) {\n        if (this.options.prefixUrl === '') {\n          throw new TypeError('Missing `url` property');\n        }\n\n        this.options.url = '';\n      }\n\n      this.requestUrl = this.options.url;\n    } catch (error) {\n      const {\n        options\n      } = error;\n\n      if (options) {\n        this.options = options;\n      }\n\n      this.flush = async () => {\n        this.flush = async () => {};\n\n        this.destroy(error);\n      };\n\n      return;\n    } // Important! If you replace `body` in a handler with another stream, make sure it's readable first.\n    // The below is run only once.\n\n\n    const {\n      body\n    } = this.options;\n\n    if (is.nodeStream(body)) {\n      body.once('error', error => {\n        if (this._flushed) {\n          this._beforeError(new UploadError(error, this));\n        } else {\n          this.flush = async () => {\n            this.flush = async () => {};\n\n            this._beforeError(new UploadError(error, this));\n          };\n        }\n      });\n    }\n\n    if (this.options.signal) {\n      const abort = () => {\n        this.destroy(new AbortError(this));\n      };\n\n      if (this.options.signal.aborted) {\n        abort();\n      } else {\n        this.options.signal.addEventListener('abort', abort);\n\n        this._removeListeners = () => {\n          this.options.signal.removeEventListener('abort', abort);\n        };\n      }\n    }\n  }\n\n  async flush() {\n    if (this._flushed) {\n      return;\n    }\n\n    this._flushed = true;\n\n    try {\n      await this._finalizeBody();\n\n      if (this.destroyed) {\n        return;\n      }\n\n      await this._makeRequest();\n\n      if (this.destroyed) {\n        this._request?.destroy();\n        return;\n      } // Queued writes etc.\n\n\n      for (const job of this._jobs) {\n        job();\n      } // Prevent memory leak\n\n\n      this._jobs.length = 0;\n      this._requestInitialized = true;\n    } catch (error) {\n      this._beforeError(error);\n    }\n  }\n\n  _beforeError(error) {\n    if (this._stopReading) {\n      return;\n    }\n\n    const {\n      response,\n      options\n    } = this;\n    const attemptCount = this.retryCount + (error.name === 'RetryError' ? 0 : 1);\n    this._stopReading = true;\n\n    if (!(error instanceof RequestError)) {\n      error = new RequestError(error.message, error, this);\n    }\n\n    const typedError = error;\n    void (async () => {\n      // Node.js parser is really weird.\n      // It emits post-request Parse Errors on the same instance as previous request. WTF.\n      // Therefore we need to check if it has been destroyed as well.\n      //\n      // Furthermore, Node.js 16 `response.destroy()` doesn't immediately destroy the socket,\n      // but makes the response unreadable. So we additionally need to check `response.readable`.\n      if (response?.readable && !response.rawBody && !this._request?.socket?.destroyed) {\n        // @types/node has incorrect typings. `setEncoding` accepts `null` as well.\n        response.setEncoding(this.readableEncoding);\n        const success = await this._setRawBody(response);\n\n        if (success) {\n          response.body = response.rawBody.toString();\n        }\n      }\n\n      if (this.listenerCount('retry') !== 0) {\n        let backoff;\n\n        try {\n          let retryAfter;\n\n          if (response && 'retry-after' in response.headers) {\n            retryAfter = Number(response.headers['retry-after']);\n\n            if (Number.isNaN(retryAfter)) {\n              retryAfter = Date.parse(response.headers['retry-after']) - Date.now();\n\n              if (retryAfter <= 0) {\n                retryAfter = 1;\n              }\n            } else {\n              retryAfter *= 1000;\n            }\n          }\n\n          const retryOptions = options.retry;\n          backoff = await retryOptions.calculateDelay({\n            attemptCount,\n            retryOptions,\n            error: typedError,\n            retryAfter,\n            computedValue: calculateRetryDelay({\n              attemptCount,\n              retryOptions,\n              error: typedError,\n              retryAfter,\n              computedValue: retryOptions.maxRetryAfter ?? options.timeout.request ?? Number.POSITIVE_INFINITY\n            })\n          });\n        } catch (error_) {\n          void this._error(new RequestError(error_.message, error_, this));\n          return;\n        }\n\n        if (backoff) {\n          await new Promise(resolve => {\n            const timeout = setTimeout(resolve, backoff);\n\n            this._stopRetry = () => {\n              clearTimeout(timeout);\n              resolve();\n            };\n          }); // Something forced us to abort the retry\n\n          if (this.destroyed) {\n            return;\n          }\n\n          try {\n            for (const hook of this.options.hooks.beforeRetry) {\n              // eslint-disable-next-line no-await-in-loop\n              await hook(typedError, this.retryCount + 1);\n            }\n          } catch (error_) {\n            void this._error(new RequestError(error_.message, error, this));\n            return;\n          } // Something forced us to abort the retry\n\n\n          if (this.destroyed) {\n            return;\n          }\n\n          this.destroy();\n          this.emit('retry', this.retryCount + 1, error, updatedOptions => {\n            const request = new Request(options.url, updatedOptions, options);\n            request.retryCount = this.retryCount + 1;\n            process.nextTick(() => {\n              void request.flush();\n            });\n            return request;\n          });\n          return;\n        }\n      }\n\n      void this._error(typedError);\n    })();\n  }\n\n  _read() {\n    this._triggerRead = true;\n    const {\n      response\n    } = this;\n\n    if (response && !this._stopReading) {\n      // We cannot put this in the `if` above\n      // because `.read()` also triggers the `end` event\n      if (response.readableLength) {\n        this._triggerRead = false;\n      }\n\n      let data;\n\n      while ((data = response.read()) !== null) {\n        this._downloadedSize += data.length; // eslint-disable-line @typescript-eslint/restrict-plus-operands\n\n        const progress = this.downloadProgress;\n\n        if (progress.percent < 1) {\n          this.emit('downloadProgress', progress);\n        }\n\n        this.push(data);\n      }\n    }\n  }\n\n  _write(chunk, encoding, callback) {\n    const write = () => {\n      this._writeRequest(chunk, encoding, callback);\n    };\n\n    if (this._requestInitialized) {\n      write();\n    } else {\n      this._jobs.push(write);\n    }\n  }\n\n  _final(callback) {\n    const endRequest = () => {\n      // We need to check if `this._request` is present,\n      // because it isn't when we use cache.\n      if (!this._request || this._request.destroyed) {\n        callback();\n        return;\n      }\n\n      this._request.end(error => {\n        // The request has been destroyed before `_final` finished.\n        // See https://github.com/nodejs/node/issues/39356\n        if (this._request._writableState?.errored) {\n          return;\n        }\n\n        if (!error) {\n          this._bodySize = this._uploadedSize;\n          this.emit('uploadProgress', this.uploadProgress);\n\n          this._request.emit('upload-complete');\n        }\n\n        callback(error);\n      });\n    };\n\n    if (this._requestInitialized) {\n      endRequest();\n    } else {\n      this._jobs.push(endRequest);\n    }\n  }\n\n  _destroy(error, callback) {\n    this._stopReading = true;\n\n    this.flush = async () => {}; // Prevent further retries\n\n\n    this._stopRetry();\n\n    this._cancelTimeouts();\n\n    this._removeListeners();\n\n    if (this.options) {\n      const {\n        body\n      } = this.options;\n\n      if (is.nodeStream(body)) {\n        body.destroy();\n      }\n    }\n\n    if (this._request) {\n      this._request.destroy();\n    }\n\n    if (error !== null && !is.undefined(error) && !(error instanceof RequestError)) {\n      error = new RequestError(error.message, error, this);\n    }\n\n    callback(error);\n  }\n\n  pipe(destination, options) {\n    if (destination instanceof ServerResponse) {\n      this._pipedServerResponses.add(destination);\n    }\n\n    return super.pipe(destination, options);\n  }\n\n  unpipe(destination) {\n    if (destination instanceof ServerResponse) {\n      this._pipedServerResponses.delete(destination);\n    }\n\n    super.unpipe(destination);\n    return this;\n  }\n\n  async _finalizeBody() {\n    const {\n      options\n    } = this;\n    const {\n      headers\n    } = options;\n    const isForm = !is.undefined(options.form); // eslint-disable-next-line @typescript-eslint/naming-convention\n\n    const isJSON = !is.undefined(options.json);\n    const isBody = !is.undefined(options.body);\n    const cannotHaveBody = methodsWithoutBody.has(options.method) && !(options.method === 'GET' && options.allowGetBody);\n    this._cannotHaveBody = cannotHaveBody;\n\n    if (isForm || isJSON || isBody) {\n      if (cannotHaveBody) {\n        throw new TypeError(`The \\`${options.method}\\` method cannot be used with a body`);\n      } // Serialize body\n\n\n      const noContentType = !is.string(headers['content-type']);\n\n      if (isBody) {\n        // Body is spec-compliant FormData\n        if (isFormDataLike(options.body)) {\n          const encoder = new FormDataEncoder(options.body);\n\n          if (noContentType) {\n            headers['content-type'] = encoder.headers['Content-Type'];\n          }\n\n          if ('Content-Length' in encoder.headers) {\n            headers['content-length'] = encoder.headers['Content-Length'];\n          }\n\n          options.body = encoder.encode();\n        } // Special case for https://github.com/form-data/form-data\n\n\n        if (isFormData(options.body) && noContentType) {\n          headers['content-type'] = `multipart/form-data; boundary=${options.body.getBoundary()}`;\n        }\n      } else if (isForm) {\n        if (noContentType) {\n          headers['content-type'] = 'application/x-www-form-urlencoded';\n        }\n\n        const {\n          form\n        } = options;\n        options.form = undefined;\n        options.body = new URLSearchParams(form).toString();\n      } else {\n        if (noContentType) {\n          headers['content-type'] = 'application/json';\n        }\n\n        const {\n          json\n        } = options;\n        options.json = undefined;\n        options.body = options.stringifyJson(json);\n      }\n\n      const uploadBodySize = await getBodySize(options.body, options.headers); // See https://tools.ietf.org/html/rfc7230#section-3.3.2\n      // A user agent SHOULD send a Content-Length in a request message when\n      // no Transfer-Encoding is sent and the request method defines a meaning\n      // for an enclosed payload body.  For example, a Content-Length header\n      // field is normally sent in a POST request even when the value is 0\n      // (indicating an empty payload body).  A user agent SHOULD NOT send a\n      // Content-Length header field when the request message does not contain\n      // a payload body and the method semantics do not anticipate such a\n      // body.\n\n      if (is.undefined(headers['content-length']) && is.undefined(headers['transfer-encoding']) && !cannotHaveBody && !is.undefined(uploadBodySize)) {\n        headers['content-length'] = String(uploadBodySize);\n      }\n    }\n\n    if (options.responseType === 'json' && !('accept' in options.headers)) {\n      options.headers.accept = 'application/json';\n    }\n\n    this._bodySize = Number(headers['content-length']) || undefined;\n  }\n\n  async _onResponseBase(response) {\n    // This will be called e.g. when using cache so we need to check if this request has been aborted.\n    if (this.isAborted) {\n      return;\n    }\n\n    const {\n      options\n    } = this;\n    const {\n      url\n    } = options;\n    this._nativeResponse = response;\n\n    if (options.decompress) {\n      response = decompressResponse(response);\n    }\n\n    const statusCode = response.statusCode;\n    const typedResponse = response;\n    typedResponse.statusMessage = typedResponse.statusMessage ?? http.STATUS_CODES[statusCode];\n    typedResponse.url = options.url.toString();\n    typedResponse.requestUrl = this.requestUrl;\n    typedResponse.redirectUrls = this.redirectUrls;\n    typedResponse.request = this;\n    typedResponse.isFromCache = this._nativeResponse.fromCache ?? false;\n    typedResponse.ip = this.ip;\n    typedResponse.retryCount = this.retryCount;\n    typedResponse.ok = isResponseOk(typedResponse);\n    this._isFromCache = typedResponse.isFromCache;\n    this._responseSize = Number(response.headers['content-length']) || undefined;\n    this.response = typedResponse;\n    response.once('end', () => {\n      this._responseSize = this._downloadedSize;\n      this.emit('downloadProgress', this.downloadProgress);\n    });\n    response.once('error', error => {\n      this._aborted = true; // Force clean-up, because some packages don't do this.\n      // TODO: Fix decompress-response\n\n      response.destroy();\n\n      this._beforeError(new ReadError(error, this));\n    });\n    response.once('aborted', () => {\n      this._aborted = true;\n\n      this._beforeError(new ReadError({\n        name: 'Error',\n        message: 'The server aborted pending request',\n        code: 'ECONNRESET'\n      }, this));\n    });\n    this.emit('downloadProgress', this.downloadProgress);\n    const rawCookies = response.headers['set-cookie'];\n\n    if (is.object(options.cookieJar) && rawCookies) {\n      let promises = rawCookies.map(async rawCookie => options.cookieJar.setCookie(rawCookie, url.toString()));\n\n      if (options.ignoreInvalidCookies) {\n        promises = promises.map(async promise => {\n          try {\n            await promise;\n          } catch {}\n        });\n      }\n\n      try {\n        await Promise.all(promises);\n      } catch (error) {\n        this._beforeError(error);\n\n        return;\n      }\n    } // The above is running a promise, therefore we need to check if this request has been aborted yet again.\n\n\n    if (this.isAborted) {\n      return;\n    }\n\n    if (options.followRedirect && response.headers.location && redirectCodes.has(statusCode)) {\n      // We're being redirected, we don't care about the response.\n      // It'd be best to abort the request, but we can't because\n      // we would have to sacrifice the TCP connection. We don't want that.\n      response.resume();\n\n      this._cancelTimeouts();\n\n      this._unproxyEvents();\n\n      if (this.redirectUrls.length >= options.maxRedirects) {\n        this._beforeError(new MaxRedirectsError(this));\n\n        return;\n      }\n\n      this._request = undefined;\n      const updatedOptions = new Options(undefined, undefined, this.options);\n      const serverRequestedGet = statusCode === 303 && updatedOptions.method !== 'GET' && updatedOptions.method !== 'HEAD';\n      const canRewrite = statusCode !== 307 && statusCode !== 308;\n      const userRequestedGet = updatedOptions.methodRewriting && canRewrite;\n\n      if (serverRequestedGet || userRequestedGet) {\n        updatedOptions.method = 'GET';\n        updatedOptions.body = undefined;\n        updatedOptions.json = undefined;\n        updatedOptions.form = undefined;\n        delete updatedOptions.headers['content-length'];\n      }\n\n      try {\n        // We need this in order to support UTF-8\n        const redirectBuffer = Buffer.from(response.headers.location, 'binary').toString();\n        const redirectUrl = new URL(redirectBuffer, url);\n\n        if (!isUnixSocketURL(url) && isUnixSocketURL(redirectUrl)) {\n          this._beforeError(new RequestError('Cannot redirect to UNIX socket', {}, this));\n\n          return;\n        } // Redirecting to a different site, clear sensitive data.\n\n\n        if (redirectUrl.hostname !== url.hostname || redirectUrl.port !== url.port) {\n          if ('host' in updatedOptions.headers) {\n            delete updatedOptions.headers.host;\n          }\n\n          if ('cookie' in updatedOptions.headers) {\n            delete updatedOptions.headers.cookie;\n          }\n\n          if ('authorization' in updatedOptions.headers) {\n            delete updatedOptions.headers.authorization;\n          }\n\n          if (updatedOptions.username || updatedOptions.password) {\n            updatedOptions.username = '';\n            updatedOptions.password = '';\n          }\n        } else {\n          redirectUrl.username = updatedOptions.username;\n          redirectUrl.password = updatedOptions.password;\n        }\n\n        this.redirectUrls.push(redirectUrl);\n        updatedOptions.prefixUrl = '';\n        updatedOptions.url = redirectUrl;\n\n        for (const hook of updatedOptions.hooks.beforeRedirect) {\n          // eslint-disable-next-line no-await-in-loop\n          await hook(updatedOptions, typedResponse);\n        }\n\n        this.emit('redirect', updatedOptions, typedResponse);\n        this.options = updatedOptions;\n        await this._makeRequest();\n      } catch (error) {\n        this._beforeError(error);\n\n        return;\n      }\n\n      return;\n    } // `HTTPError`s always have `error.response.body` defined.\n    // Therefore we cannot retry if `options.throwHttpErrors` is false.\n    // On the last retry, if `options.throwHttpErrors` is false, we would need to return the body,\n    // but that wouldn't be possible since the body would be already read in `error.response.body`.\n\n\n    if (options.isStream && options.throwHttpErrors && !isResponseOk(typedResponse)) {\n      this._beforeError(new HTTPError(typedResponse));\n\n      return;\n    }\n\n    response.on('readable', () => {\n      if (this._triggerRead) {\n        this._read();\n      }\n    });\n    this.on('resume', () => {\n      response.resume();\n    });\n    this.on('pause', () => {\n      response.pause();\n    });\n    response.once('end', () => {\n      this.push(null);\n    });\n\n    if (this._noPipe) {\n      const success = await this._setRawBody();\n\n      if (success) {\n        this.emit('response', response);\n      }\n\n      return;\n    }\n\n    this.emit('response', response);\n\n    for (const destination of this._pipedServerResponses) {\n      if (destination.headersSent) {\n        continue;\n      } // eslint-disable-next-line guard-for-in\n\n\n      for (const key in response.headers) {\n        const isAllowed = options.decompress ? key !== 'content-encoding' : true;\n        const value = response.headers[key];\n\n        if (isAllowed) {\n          destination.setHeader(key, value);\n        }\n      }\n\n      destination.statusCode = statusCode;\n    }\n  }\n\n  async _setRawBody(from = this) {\n    if (from.readableEnded) {\n      return false;\n    }\n\n    try {\n      // Errors are emitted via the `error` event\n      const rawBody = await getBuffer(from); // On retry Request is destroyed with no error, therefore the above will successfully resolve.\n      // So in order to check if this was really successfull, we need to check if it has been properly ended.\n\n      if (!this.isAborted) {\n        this.response.rawBody = rawBody;\n        return true;\n      }\n    } catch {}\n\n    return false;\n  }\n\n  async _onResponse(response) {\n    try {\n      await this._onResponseBase(response);\n    } catch (error) {\n      /* istanbul ignore next: better safe than sorry */\n      this._beforeError(error);\n    }\n  }\n\n  _onRequest(request) {\n    const {\n      options\n    } = this;\n    const {\n      timeout,\n      url\n    } = options;\n    timer(request);\n\n    if (this.options.http2) {\n      // Unset stream timeout, as the `timeout` option was used only for connection timeout.\n      request.setTimeout(0);\n    }\n\n    this._cancelTimeouts = timedOut(request, timeout, url);\n    const responseEventName = options.cache ? 'cacheableResponse' : 'response';\n    request.once(responseEventName, response => {\n      void this._onResponse(response);\n    });\n    request.once('error', error => {\n      this._aborted = true; // Force clean-up, because some packages (e.g. nock) don't do this.\n\n      request.destroy();\n      error = error instanceof TimedOutTimeoutError ? new TimeoutError(error, this.timings, this) : new RequestError(error.message, error, this);\n\n      this._beforeError(error);\n    });\n    this._unproxyEvents = proxyEvents(request, this, proxiedRequestEvents);\n    this._request = request;\n    this.emit('uploadProgress', this.uploadProgress);\n\n    this._sendBody();\n\n    this.emit('request', request);\n  }\n\n  async _asyncWrite(chunk) {\n    return new Promise((resolve, reject) => {\n      super.write(chunk, error => {\n        if (error) {\n          reject(error);\n          return;\n        }\n\n        resolve();\n      });\n    });\n  }\n\n  _sendBody() {\n    // Send body\n    const {\n      body\n    } = this.options;\n    const currentRequest = this.redirectUrls.length === 0 ? this : this._request ?? this;\n\n    if (is.nodeStream(body)) {\n      body.pipe(currentRequest);\n    } else if (is.generator(body) || is.asyncGenerator(body)) {\n      (async () => {\n        try {\n          for await (const chunk of body) {\n            await this._asyncWrite(chunk);\n          }\n\n          super.end();\n        } catch (error) {\n          this._beforeError(error);\n        }\n      })();\n    } else if (!is.undefined(body)) {\n      this._writeRequest(body, undefined, () => {});\n\n      currentRequest.end();\n    } else if (this._cannotHaveBody || this._noPipe) {\n      currentRequest.end();\n    }\n  }\n\n  _prepareCache(cache) {\n    if (!cacheableStore.has(cache)) {\n      const cacheableRequest = new CacheableRequest((requestOptions, handler) => {\n        const result = requestOptions._request(requestOptions, handler); // TODO: remove this when `cacheable-request` supports async request functions.\n\n\n        if (is.promise(result)) {\n          // We only need to implement the error handler in order to support HTTP2 caching.\n          // The result will be a promise anyway.\n          // @ts-expect-error ignore\n          // eslint-disable-next-line @typescript-eslint/promise-function-async\n          result.once = (event, handler) => {\n            if (event === 'error') {\n              (async () => {\n                try {\n                  await result;\n                } catch (error) {\n                  handler(error);\n                }\n              })();\n            } else if (event === 'abort') {\n              // The empty catch is needed here in case when\n              // it rejects before it's `await`ed in `_makeRequest`.\n              (async () => {\n                try {\n                  const request = await result;\n                  request.once('abort', handler);\n                } catch {}\n              })();\n            } else {\n              /* istanbul ignore next: safety check */\n              throw new Error(`Unknown HTTP2 promise event: ${event}`);\n            }\n\n            return result;\n          };\n        }\n\n        return result;\n      }, cache);\n      cacheableStore.set(cache, cacheableRequest.request());\n    }\n  }\n\n  async _createCacheableRequest(url, options) {\n    return new Promise((resolve, reject) => {\n      // TODO: Remove `utils/url-to-options.ts` when `cacheable-request` is fixed\n      Object.assign(options, urlToOptions(url));\n      let request; // TODO: Fix `cacheable-response`. This is ugly.\n\n      const cacheRequest = cacheableStore.get(options.cache)(options, async response => {\n        response._readableState.autoDestroy = false;\n\n        if (request) {\n          const fix = () => {\n            if (response.req) {\n              response.complete = response.req.res.complete;\n            }\n          };\n\n          response.prependOnceListener('end', fix);\n          fix();\n          (await request).emit('cacheableResponse', response);\n        }\n\n        resolve(response);\n      });\n      cacheRequest.once('error', reject);\n      cacheRequest.once('request', async requestOrPromise => {\n        request = requestOrPromise;\n        resolve(request);\n      });\n    });\n  }\n\n  async _makeRequest() {\n    const {\n      options\n    } = this;\n    const {\n      headers,\n      username,\n      password\n    } = options;\n    const cookieJar = options.cookieJar;\n\n    for (const key in headers) {\n      if (is.undefined(headers[key])) {\n        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n        delete headers[key];\n      } else if (is.null_(headers[key])) {\n        throw new TypeError(`Use \\`undefined\\` instead of \\`null\\` to delete the \\`${key}\\` header`);\n      }\n    }\n\n    if (options.decompress && is.undefined(headers['accept-encoding'])) {\n      headers['accept-encoding'] = supportsBrotli ? 'gzip, deflate, br' : 'gzip, deflate';\n    }\n\n    if (username || password) {\n      const credentials = Buffer.from(`${username}:${password}`).toString('base64');\n      headers.authorization = `Basic ${credentials}`;\n    } // Set cookies\n\n\n    if (cookieJar) {\n      const cookieString = await cookieJar.getCookieString(options.url.toString());\n\n      if (is.nonEmptyString(cookieString)) {\n        headers.cookie = cookieString;\n      }\n    } // Reset `prefixUrl`\n\n\n    options.prefixUrl = '';\n    let request;\n\n    for (const hook of options.hooks.beforeRequest) {\n      // eslint-disable-next-line no-await-in-loop\n      const result = await hook(options);\n\n      if (!is.undefined(result)) {\n        // @ts-expect-error Skip the type mismatch to support abstract responses\n        request = () => result;\n\n        break;\n      }\n    }\n\n    if (!request) {\n      request = options.getRequestFunction();\n    }\n\n    const url = options.url;\n    this._requestOptions = options.createNativeRequestOptions();\n\n    if (options.cache) {\n      this._requestOptions._request = request;\n      this._requestOptions.cache = options.cache;\n      this._requestOptions.body = options.body;\n\n      this._prepareCache(options.cache);\n    } // Cache support\n\n\n    const fn = options.cache ? this._createCacheableRequest : request;\n\n    try {\n      // We can't do `await fn(...)`,\n      // because stream `error` event can be emitted before `Promise.resolve()`.\n      let requestOrResponse = fn(url, this._requestOptions);\n\n      if (is.promise(requestOrResponse)) {\n        requestOrResponse = await requestOrResponse;\n      } // Fallback\n\n\n      if (is.undefined(requestOrResponse)) {\n        requestOrResponse = options.getFallbackRequestFunction()(url, this._requestOptions);\n\n        if (is.promise(requestOrResponse)) {\n          requestOrResponse = await requestOrResponse;\n        }\n      }\n\n      if (isClientRequest(requestOrResponse)) {\n        this._onRequest(requestOrResponse);\n      } else if (this.writable) {\n        this.once('finish', () => {\n          void this._onResponse(requestOrResponse);\n        });\n\n        this._sendBody();\n      } else {\n        void this._onResponse(requestOrResponse);\n      }\n    } catch (error) {\n      if (error instanceof CacheableCacheError) {\n        throw new CacheError(error, this);\n      }\n\n      throw error;\n    }\n  }\n\n  async _error(error) {\n    try {\n      if (error instanceof HTTPError && !this.options.throwHttpErrors) {// This branch can be reached only when using the Promise API\n        // Skip calling the hooks on purpose.\n        // See https://github.com/sindresorhus/got/issues/2103\n      } else {\n        for (const hook of this.options.hooks.beforeError) {\n          // eslint-disable-next-line no-await-in-loop\n          error = await hook(error);\n        }\n      }\n    } catch (error_) {\n      error = new RequestError(error_.message, error_, this);\n    }\n\n    this.destroy(error);\n  }\n\n  _writeRequest(chunk, encoding, callback) {\n    if (!this._request || this._request.destroyed) {\n      // Probably the `ClientRequest` instance will throw\n      return;\n    }\n\n    this._request.write(chunk, encoding, error => {\n      // The `!destroyed` check is required to prevent `uploadProgress` being emitted after the stream was destroyed\n      if (!error && !this._request.destroyed) {\n        this._uploadedSize += Buffer.byteLength(chunk, encoding);\n        const progress = this.uploadProgress;\n\n        if (progress.percent < 1) {\n          this.emit('uploadProgress', progress);\n        }\n      }\n\n      callback(error);\n    });\n  }\n  /**\n  The remote IP address.\n  */\n\n\n  get ip() {\n    return this.socket?.remoteAddress;\n  }\n  /**\n  Indicates whether the request has been aborted or not.\n  */\n\n\n  get isAborted() {\n    return this._aborted;\n  }\n\n  get socket() {\n    return this._request?.socket ?? undefined;\n  }\n  /**\n  Progress event for downloading (receiving a response).\n  */\n\n\n  get downloadProgress() {\n    let percent;\n\n    if (this._responseSize) {\n      percent = this._downloadedSize / this._responseSize;\n    } else if (this._responseSize === this._downloadedSize) {\n      percent = 1;\n    } else {\n      percent = 0;\n    }\n\n    return {\n      percent,\n      transferred: this._downloadedSize,\n      total: this._responseSize\n    };\n  }\n  /**\n  Progress event for uploading (sending a request).\n  */\n\n\n  get uploadProgress() {\n    let percent;\n\n    if (this._bodySize) {\n      percent = this._uploadedSize / this._bodySize;\n    } else if (this._bodySize === this._uploadedSize) {\n      percent = 1;\n    } else {\n      percent = 0;\n    }\n\n    return {\n      percent,\n      transferred: this._uploadedSize,\n      total: this._bodySize\n    };\n  }\n  /**\n  The object contains the following properties:\n   - `start` - Time when the request started.\n  - `socket` - Time when a socket was assigned to the request.\n  - `lookup` - Time when the DNS lookup finished.\n  - `connect` - Time when the socket successfully connected.\n  - `secureConnect` - Time when the socket securely connected.\n  - `upload` - Time when the request finished uploading.\n  - `response` - Time when the request fired `response` event.\n  - `end` - Time when the response fired `end` event.\n  - `error` - Time when the request fired `error` event.\n  - `abort` - Time when the request fired `abort` event.\n  - `phases`\n      - `wait` - `timings.socket - timings.start`\n      - `dns` - `timings.lookup - timings.socket`\n      - `tcp` - `timings.connect - timings.lookup`\n      - `tls` - `timings.secureConnect - timings.connect`\n      - `request` - `timings.upload - (timings.secureConnect || timings.connect)`\n      - `firstByte` - `timings.response - timings.upload`\n      - `download` - `timings.end - timings.response`\n      - `total` - `(timings.end || timings.error || timings.abort) - timings.start`\n   If something has not been measured yet, it will be `undefined`.\n   __Note__: The time is a `number` representing the milliseconds elapsed since the UNIX epoch.\n  */\n\n\n  get timings() {\n    return this._request?.timings;\n  }\n  /**\n  Whether the response was retrieved from the cache.\n  */\n\n\n  get isFromCache() {\n    return this._isFromCache;\n  }\n\n  get reusedSocket() {\n    return this._request?.reusedSocket;\n  }\n\n}","map":{"version":3,"names":["process","Buffer","Duplex","URL","URLSearchParams","http","ServerResponse","timer","CacheableRequest","CacheError","CacheableCacheError","decompressResponse","is","buffer","getBuffer","FormDataEncoder","isFormData","isFormDataLike","getBodySize","proxyEvents","timedOut","TimeoutError","TimedOutTimeoutError","urlToOptions","WeakableMap","calculateRetryDelay","Options","isResponseOk","isClientRequest","isUnixSocketURL","RequestError","ReadError","MaxRedirectsError","HTTPError","UploadError","AbortError","supportsBrotli","string","versions","brotli","methodsWithoutBody","Set","cacheableStore","redirectCodes","proxiedRequestEvents","noop","Request","constructor","url","options","defaults","autoDestroy","highWaterMark","Object","defineProperty","enumerable","configurable","writable","value","_downloadedSize","_uploadedSize","_stopReading","_pipedServerResponses","_cannotHaveBody","_unproxyEvents","_triggerRead","_cancelTimeouts","_removeListeners","_jobs","_flushed","_requestInitialized","_aborted","redirectUrls","retryCount","_stopRetry","on","source","headers","assign","event","listenerCount","Error","prefixUrl","TypeError","requestUrl","error","flush","destroy","body","nodeStream","once","_beforeError","signal","abort","aborted","addEventListener","removeEventListener","_finalizeBody","destroyed","_makeRequest","_request","job","length","response","attemptCount","name","message","typedError","readable","rawBody","socket","setEncoding","readableEncoding","success","_setRawBody","toString","backoff","retryAfter","Number","isNaN","Date","parse","now","retryOptions","retry","calculateDelay","computedValue","maxRetryAfter","timeout","request","POSITIVE_INFINITY","error_","_error","Promise","resolve","setTimeout","clearTimeout","hook","hooks","beforeRetry","emit","updatedOptions","nextTick","_read","readableLength","data","read","progress","downloadProgress","percent","push","_write","chunk","encoding","callback","write","_writeRequest","_final","endRequest","end","_writableState","errored","_bodySize","uploadProgress","_destroy","undefined","pipe","destination","add","unpipe","delete","isForm","form","isJSON","json","isBody","cannotHaveBody","has","method","allowGetBody","noContentType","encoder","encode","getBoundary","stringifyJson","uploadBodySize","String","responseType","accept","_onResponseBase","isAborted","_nativeResponse","decompress","statusCode","typedResponse","statusMessage","STATUS_CODES","isFromCache","fromCache","ip","ok","_isFromCache","_responseSize","code","rawCookies","object","cookieJar","promises","map","rawCookie","setCookie","ignoreInvalidCookies","promise","all","followRedirect","location","resume","maxRedirects","serverRequestedGet","canRewrite","userRequestedGet","methodRewriting","redirectBuffer","from","redirectUrl","hostname","port","host","cookie","authorization","username","password","beforeRedirect","isStream","throwHttpErrors","pause","_noPipe","headersSent","key","isAllowed","setHeader","readableEnded","_onResponse","_onRequest","http2","responseEventName","cache","timings","_sendBody","_asyncWrite","reject","currentRequest","generator","asyncGenerator","_prepareCache","cacheableRequest","requestOptions","handler","result","set","_createCacheableRequest","cacheRequest","get","_readableState","fix","req","complete","res","prependOnceListener","requestOrPromise","null_","credentials","cookieString","getCookieString","nonEmptyString","beforeRequest","getRequestFunction","_requestOptions","createNativeRequestOptions","fn","requestOrResponse","getFallbackRequestFunction","beforeError","byteLength","remoteAddress","transferred","total","reusedSocket"],"sources":["/Users/joshgoodman/Documents/GitHub/tententranslations/vuefrontend/node_modules/ipify/node_modules/got/dist/source/core/index.js"],"sourcesContent":["import process from 'node:process';\nimport { Buffer } from 'node:buffer';\nimport { Duplex } from 'node:stream';\nimport { URL, URLSearchParams } from 'node:url';\nimport http, { ServerResponse } from 'node:http';\nimport timer from '@szmarczak/http-timer';\nimport CacheableRequest, { CacheError as CacheableCacheError, } from 'cacheable-request';\nimport decompressResponse from 'decompress-response';\nimport is from '@sindresorhus/is';\nimport { buffer as getBuffer } from 'get-stream';\nimport { FormDataEncoder, isFormData as isFormDataLike } from 'form-data-encoder';\nimport getBodySize from './utils/get-body-size.js';\nimport isFormData from './utils/is-form-data.js';\nimport proxyEvents from './utils/proxy-events.js';\nimport timedOut, { TimeoutError as TimedOutTimeoutError } from './timed-out.js';\nimport urlToOptions from './utils/url-to-options.js';\nimport WeakableMap from './utils/weakable-map.js';\nimport calculateRetryDelay from './calculate-retry-delay.js';\nimport Options from './options.js';\nimport { isResponseOk } from './response.js';\nimport isClientRequest from './utils/is-client-request.js';\nimport isUnixSocketURL from './utils/is-unix-socket-url.js';\nimport { RequestError, ReadError, MaxRedirectsError, HTTPError, TimeoutError, UploadError, CacheError, AbortError, } from './errors.js';\nconst supportsBrotli = is.string(process.versions.brotli);\nconst methodsWithoutBody = new Set(['GET', 'HEAD']);\nconst cacheableStore = new WeakableMap();\nconst redirectCodes = new Set([300, 301, 302, 303, 304, 307, 308]);\nconst proxiedRequestEvents = [\n    'socket',\n    'connect',\n    'continue',\n    'information',\n    'upgrade',\n];\nconst noop = () => { };\nexport default class Request extends Duplex {\n    constructor(url, options, defaults) {\n        super({\n            // Don't destroy immediately, as the error may be emitted on unsuccessful retry\n            autoDestroy: false,\n            // It needs to be zero because we're just proxying the data to another stream\n            highWaterMark: 0,\n        });\n        // @ts-expect-error - Ignoring for now.\n        Object.defineProperty(this, 'constructor', {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_noPipe\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // @ts-expect-error https://github.com/microsoft/TypeScript/issues/9568\n        Object.defineProperty(this, \"options\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"response\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"requestUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"redirectUrls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"retryCount\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_stopRetry\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_downloadedSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_uploadedSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_stopReading\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_pipedServerResponses\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_request\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_responseSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_bodySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_unproxyEvents\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_isFromCache\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_cannotHaveBody\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_triggerRead\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_cancelTimeouts\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_removeListeners\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_nativeResponse\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_flushed\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_aborted\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // We need this because `this._request` if `undefined` when using cache\n        Object.defineProperty(this, \"_requestInitialized\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this._downloadedSize = 0;\n        this._uploadedSize = 0;\n        this._stopReading = false;\n        this._pipedServerResponses = new Set();\n        this._cannotHaveBody = false;\n        this._unproxyEvents = noop;\n        this._triggerRead = false;\n        this._cancelTimeouts = noop;\n        this._removeListeners = noop;\n        this._jobs = [];\n        this._flushed = false;\n        this._requestInitialized = false;\n        this._aborted = false;\n        this.redirectUrls = [];\n        this.retryCount = 0;\n        this._stopRetry = noop;\n        this.on('pipe', source => {\n            if (source.headers) {\n                Object.assign(this.options.headers, source.headers);\n            }\n        });\n        this.on('newListener', event => {\n            if (event === 'retry' && this.listenerCount('retry') > 0) {\n                throw new Error('A retry listener has been attached already.');\n            }\n        });\n        try {\n            this.options = new Options(url, options, defaults);\n            if (!this.options.url) {\n                if (this.options.prefixUrl === '') {\n                    throw new TypeError('Missing `url` property');\n                }\n                this.options.url = '';\n            }\n            this.requestUrl = this.options.url;\n        }\n        catch (error) {\n            const { options } = error;\n            if (options) {\n                this.options = options;\n            }\n            this.flush = async () => {\n                this.flush = async () => { };\n                this.destroy(error);\n            };\n            return;\n        }\n        // Important! If you replace `body` in a handler with another stream, make sure it's readable first.\n        // The below is run only once.\n        const { body } = this.options;\n        if (is.nodeStream(body)) {\n            body.once('error', error => {\n                if (this._flushed) {\n                    this._beforeError(new UploadError(error, this));\n                }\n                else {\n                    this.flush = async () => {\n                        this.flush = async () => { };\n                        this._beforeError(new UploadError(error, this));\n                    };\n                }\n            });\n        }\n        if (this.options.signal) {\n            const abort = () => {\n                this.destroy(new AbortError(this));\n            };\n            if (this.options.signal.aborted) {\n                abort();\n            }\n            else {\n                this.options.signal.addEventListener('abort', abort);\n                this._removeListeners = () => {\n                    this.options.signal.removeEventListener('abort', abort);\n                };\n            }\n        }\n    }\n    async flush() {\n        if (this._flushed) {\n            return;\n        }\n        this._flushed = true;\n        try {\n            await this._finalizeBody();\n            if (this.destroyed) {\n                return;\n            }\n            await this._makeRequest();\n            if (this.destroyed) {\n                this._request?.destroy();\n                return;\n            }\n            // Queued writes etc.\n            for (const job of this._jobs) {\n                job();\n            }\n            // Prevent memory leak\n            this._jobs.length = 0;\n            this._requestInitialized = true;\n        }\n        catch (error) {\n            this._beforeError(error);\n        }\n    }\n    _beforeError(error) {\n        if (this._stopReading) {\n            return;\n        }\n        const { response, options } = this;\n        const attemptCount = this.retryCount + (error.name === 'RetryError' ? 0 : 1);\n        this._stopReading = true;\n        if (!(error instanceof RequestError)) {\n            error = new RequestError(error.message, error, this);\n        }\n        const typedError = error;\n        void (async () => {\n            // Node.js parser is really weird.\n            // It emits post-request Parse Errors on the same instance as previous request. WTF.\n            // Therefore we need to check if it has been destroyed as well.\n            //\n            // Furthermore, Node.js 16 `response.destroy()` doesn't immediately destroy the socket,\n            // but makes the response unreadable. So we additionally need to check `response.readable`.\n            if (response?.readable && !response.rawBody && !this._request?.socket?.destroyed) {\n                // @types/node has incorrect typings. `setEncoding` accepts `null` as well.\n                response.setEncoding(this.readableEncoding);\n                const success = await this._setRawBody(response);\n                if (success) {\n                    response.body = response.rawBody.toString();\n                }\n            }\n            if (this.listenerCount('retry') !== 0) {\n                let backoff;\n                try {\n                    let retryAfter;\n                    if (response && 'retry-after' in response.headers) {\n                        retryAfter = Number(response.headers['retry-after']);\n                        if (Number.isNaN(retryAfter)) {\n                            retryAfter = Date.parse(response.headers['retry-after']) - Date.now();\n                            if (retryAfter <= 0) {\n                                retryAfter = 1;\n                            }\n                        }\n                        else {\n                            retryAfter *= 1000;\n                        }\n                    }\n                    const retryOptions = options.retry;\n                    backoff = await retryOptions.calculateDelay({\n                        attemptCount,\n                        retryOptions,\n                        error: typedError,\n                        retryAfter,\n                        computedValue: calculateRetryDelay({\n                            attemptCount,\n                            retryOptions,\n                            error: typedError,\n                            retryAfter,\n                            computedValue: retryOptions.maxRetryAfter ?? options.timeout.request ?? Number.POSITIVE_INFINITY,\n                        }),\n                    });\n                }\n                catch (error_) {\n                    void this._error(new RequestError(error_.message, error_, this));\n                    return;\n                }\n                if (backoff) {\n                    await new Promise(resolve => {\n                        const timeout = setTimeout(resolve, backoff);\n                        this._stopRetry = () => {\n                            clearTimeout(timeout);\n                            resolve();\n                        };\n                    });\n                    // Something forced us to abort the retry\n                    if (this.destroyed) {\n                        return;\n                    }\n                    try {\n                        for (const hook of this.options.hooks.beforeRetry) {\n                            // eslint-disable-next-line no-await-in-loop\n                            await hook(typedError, this.retryCount + 1);\n                        }\n                    }\n                    catch (error_) {\n                        void this._error(new RequestError(error_.message, error, this));\n                        return;\n                    }\n                    // Something forced us to abort the retry\n                    if (this.destroyed) {\n                        return;\n                    }\n                    this.destroy();\n                    this.emit('retry', this.retryCount + 1, error, (updatedOptions) => {\n                        const request = new Request(options.url, updatedOptions, options);\n                        request.retryCount = this.retryCount + 1;\n                        process.nextTick(() => {\n                            void request.flush();\n                        });\n                        return request;\n                    });\n                    return;\n                }\n            }\n            void this._error(typedError);\n        })();\n    }\n    _read() {\n        this._triggerRead = true;\n        const { response } = this;\n        if (response && !this._stopReading) {\n            // We cannot put this in the `if` above\n            // because `.read()` also triggers the `end` event\n            if (response.readableLength) {\n                this._triggerRead = false;\n            }\n            let data;\n            while ((data = response.read()) !== null) {\n                this._downloadedSize += data.length; // eslint-disable-line @typescript-eslint/restrict-plus-operands\n                const progress = this.downloadProgress;\n                if (progress.percent < 1) {\n                    this.emit('downloadProgress', progress);\n                }\n                this.push(data);\n            }\n        }\n    }\n    _write(chunk, encoding, callback) {\n        const write = () => {\n            this._writeRequest(chunk, encoding, callback);\n        };\n        if (this._requestInitialized) {\n            write();\n        }\n        else {\n            this._jobs.push(write);\n        }\n    }\n    _final(callback) {\n        const endRequest = () => {\n            // We need to check if `this._request` is present,\n            // because it isn't when we use cache.\n            if (!this._request || this._request.destroyed) {\n                callback();\n                return;\n            }\n            this._request.end((error) => {\n                // The request has been destroyed before `_final` finished.\n                // See https://github.com/nodejs/node/issues/39356\n                if (this._request._writableState?.errored) {\n                    return;\n                }\n                if (!error) {\n                    this._bodySize = this._uploadedSize;\n                    this.emit('uploadProgress', this.uploadProgress);\n                    this._request.emit('upload-complete');\n                }\n                callback(error);\n            });\n        };\n        if (this._requestInitialized) {\n            endRequest();\n        }\n        else {\n            this._jobs.push(endRequest);\n        }\n    }\n    _destroy(error, callback) {\n        this._stopReading = true;\n        this.flush = async () => { };\n        // Prevent further retries\n        this._stopRetry();\n        this._cancelTimeouts();\n        this._removeListeners();\n        if (this.options) {\n            const { body } = this.options;\n            if (is.nodeStream(body)) {\n                body.destroy();\n            }\n        }\n        if (this._request) {\n            this._request.destroy();\n        }\n        if (error !== null && !is.undefined(error) && !(error instanceof RequestError)) {\n            error = new RequestError(error.message, error, this);\n        }\n        callback(error);\n    }\n    pipe(destination, options) {\n        if (destination instanceof ServerResponse) {\n            this._pipedServerResponses.add(destination);\n        }\n        return super.pipe(destination, options);\n    }\n    unpipe(destination) {\n        if (destination instanceof ServerResponse) {\n            this._pipedServerResponses.delete(destination);\n        }\n        super.unpipe(destination);\n        return this;\n    }\n    async _finalizeBody() {\n        const { options } = this;\n        const { headers } = options;\n        const isForm = !is.undefined(options.form);\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        const isJSON = !is.undefined(options.json);\n        const isBody = !is.undefined(options.body);\n        const cannotHaveBody = methodsWithoutBody.has(options.method) && !(options.method === 'GET' && options.allowGetBody);\n        this._cannotHaveBody = cannotHaveBody;\n        if (isForm || isJSON || isBody) {\n            if (cannotHaveBody) {\n                throw new TypeError(`The \\`${options.method}\\` method cannot be used with a body`);\n            }\n            // Serialize body\n            const noContentType = !is.string(headers['content-type']);\n            if (isBody) {\n                // Body is spec-compliant FormData\n                if (isFormDataLike(options.body)) {\n                    const encoder = new FormDataEncoder(options.body);\n                    if (noContentType) {\n                        headers['content-type'] = encoder.headers['Content-Type'];\n                    }\n                    if ('Content-Length' in encoder.headers) {\n                        headers['content-length'] = encoder.headers['Content-Length'];\n                    }\n                    options.body = encoder.encode();\n                }\n                // Special case for https://github.com/form-data/form-data\n                if (isFormData(options.body) && noContentType) {\n                    headers['content-type'] = `multipart/form-data; boundary=${options.body.getBoundary()}`;\n                }\n            }\n            else if (isForm) {\n                if (noContentType) {\n                    headers['content-type'] = 'application/x-www-form-urlencoded';\n                }\n                const { form } = options;\n                options.form = undefined;\n                options.body = (new URLSearchParams(form)).toString();\n            }\n            else {\n                if (noContentType) {\n                    headers['content-type'] = 'application/json';\n                }\n                const { json } = options;\n                options.json = undefined;\n                options.body = options.stringifyJson(json);\n            }\n            const uploadBodySize = await getBodySize(options.body, options.headers);\n            // See https://tools.ietf.org/html/rfc7230#section-3.3.2\n            // A user agent SHOULD send a Content-Length in a request message when\n            // no Transfer-Encoding is sent and the request method defines a meaning\n            // for an enclosed payload body.  For example, a Content-Length header\n            // field is normally sent in a POST request even when the value is 0\n            // (indicating an empty payload body).  A user agent SHOULD NOT send a\n            // Content-Length header field when the request message does not contain\n            // a payload body and the method semantics do not anticipate such a\n            // body.\n            if (is.undefined(headers['content-length']) && is.undefined(headers['transfer-encoding']) && !cannotHaveBody && !is.undefined(uploadBodySize)) {\n                headers['content-length'] = String(uploadBodySize);\n            }\n        }\n        if (options.responseType === 'json' && !('accept' in options.headers)) {\n            options.headers.accept = 'application/json';\n        }\n        this._bodySize = Number(headers['content-length']) || undefined;\n    }\n    async _onResponseBase(response) {\n        // This will be called e.g. when using cache so we need to check if this request has been aborted.\n        if (this.isAborted) {\n            return;\n        }\n        const { options } = this;\n        const { url } = options;\n        this._nativeResponse = response;\n        if (options.decompress) {\n            response = decompressResponse(response);\n        }\n        const statusCode = response.statusCode;\n        const typedResponse = response;\n        typedResponse.statusMessage = typedResponse.statusMessage ?? http.STATUS_CODES[statusCode];\n        typedResponse.url = options.url.toString();\n        typedResponse.requestUrl = this.requestUrl;\n        typedResponse.redirectUrls = this.redirectUrls;\n        typedResponse.request = this;\n        typedResponse.isFromCache = this._nativeResponse.fromCache ?? false;\n        typedResponse.ip = this.ip;\n        typedResponse.retryCount = this.retryCount;\n        typedResponse.ok = isResponseOk(typedResponse);\n        this._isFromCache = typedResponse.isFromCache;\n        this._responseSize = Number(response.headers['content-length']) || undefined;\n        this.response = typedResponse;\n        response.once('end', () => {\n            this._responseSize = this._downloadedSize;\n            this.emit('downloadProgress', this.downloadProgress);\n        });\n        response.once('error', (error) => {\n            this._aborted = true;\n            // Force clean-up, because some packages don't do this.\n            // TODO: Fix decompress-response\n            response.destroy();\n            this._beforeError(new ReadError(error, this));\n        });\n        response.once('aborted', () => {\n            this._aborted = true;\n            this._beforeError(new ReadError({\n                name: 'Error',\n                message: 'The server aborted pending request',\n                code: 'ECONNRESET',\n            }, this));\n        });\n        this.emit('downloadProgress', this.downloadProgress);\n        const rawCookies = response.headers['set-cookie'];\n        if (is.object(options.cookieJar) && rawCookies) {\n            let promises = rawCookies.map(async (rawCookie) => options.cookieJar.setCookie(rawCookie, url.toString()));\n            if (options.ignoreInvalidCookies) {\n                promises = promises.map(async (promise) => {\n                    try {\n                        await promise;\n                    }\n                    catch { }\n                });\n            }\n            try {\n                await Promise.all(promises);\n            }\n            catch (error) {\n                this._beforeError(error);\n                return;\n            }\n        }\n        // The above is running a promise, therefore we need to check if this request has been aborted yet again.\n        if (this.isAborted) {\n            return;\n        }\n        if (options.followRedirect && response.headers.location && redirectCodes.has(statusCode)) {\n            // We're being redirected, we don't care about the response.\n            // It'd be best to abort the request, but we can't because\n            // we would have to sacrifice the TCP connection. We don't want that.\n            response.resume();\n            this._cancelTimeouts();\n            this._unproxyEvents();\n            if (this.redirectUrls.length >= options.maxRedirects) {\n                this._beforeError(new MaxRedirectsError(this));\n                return;\n            }\n            this._request = undefined;\n            const updatedOptions = new Options(undefined, undefined, this.options);\n            const serverRequestedGet = statusCode === 303 && updatedOptions.method !== 'GET' && updatedOptions.method !== 'HEAD';\n            const canRewrite = statusCode !== 307 && statusCode !== 308;\n            const userRequestedGet = updatedOptions.methodRewriting && canRewrite;\n            if (serverRequestedGet || userRequestedGet) {\n                updatedOptions.method = 'GET';\n                updatedOptions.body = undefined;\n                updatedOptions.json = undefined;\n                updatedOptions.form = undefined;\n                delete updatedOptions.headers['content-length'];\n            }\n            try {\n                // We need this in order to support UTF-8\n                const redirectBuffer = Buffer.from(response.headers.location, 'binary').toString();\n                const redirectUrl = new URL(redirectBuffer, url);\n                if (!isUnixSocketURL(url) && isUnixSocketURL(redirectUrl)) {\n                    this._beforeError(new RequestError('Cannot redirect to UNIX socket', {}, this));\n                    return;\n                }\n                // Redirecting to a different site, clear sensitive data.\n                if (redirectUrl.hostname !== url.hostname || redirectUrl.port !== url.port) {\n                    if ('host' in updatedOptions.headers) {\n                        delete updatedOptions.headers.host;\n                    }\n                    if ('cookie' in updatedOptions.headers) {\n                        delete updatedOptions.headers.cookie;\n                    }\n                    if ('authorization' in updatedOptions.headers) {\n                        delete updatedOptions.headers.authorization;\n                    }\n                    if (updatedOptions.username || updatedOptions.password) {\n                        updatedOptions.username = '';\n                        updatedOptions.password = '';\n                    }\n                }\n                else {\n                    redirectUrl.username = updatedOptions.username;\n                    redirectUrl.password = updatedOptions.password;\n                }\n                this.redirectUrls.push(redirectUrl);\n                updatedOptions.prefixUrl = '';\n                updatedOptions.url = redirectUrl;\n                for (const hook of updatedOptions.hooks.beforeRedirect) {\n                    // eslint-disable-next-line no-await-in-loop\n                    await hook(updatedOptions, typedResponse);\n                }\n                this.emit('redirect', updatedOptions, typedResponse);\n                this.options = updatedOptions;\n                await this._makeRequest();\n            }\n            catch (error) {\n                this._beforeError(error);\n                return;\n            }\n            return;\n        }\n        // `HTTPError`s always have `error.response.body` defined.\n        // Therefore we cannot retry if `options.throwHttpErrors` is false.\n        // On the last retry, if `options.throwHttpErrors` is false, we would need to return the body,\n        // but that wouldn't be possible since the body would be already read in `error.response.body`.\n        if (options.isStream && options.throwHttpErrors && !isResponseOk(typedResponse)) {\n            this._beforeError(new HTTPError(typedResponse));\n            return;\n        }\n        response.on('readable', () => {\n            if (this._triggerRead) {\n                this._read();\n            }\n        });\n        this.on('resume', () => {\n            response.resume();\n        });\n        this.on('pause', () => {\n            response.pause();\n        });\n        response.once('end', () => {\n            this.push(null);\n        });\n        if (this._noPipe) {\n            const success = await this._setRawBody();\n            if (success) {\n                this.emit('response', response);\n            }\n            return;\n        }\n        this.emit('response', response);\n        for (const destination of this._pipedServerResponses) {\n            if (destination.headersSent) {\n                continue;\n            }\n            // eslint-disable-next-line guard-for-in\n            for (const key in response.headers) {\n                const isAllowed = options.decompress ? key !== 'content-encoding' : true;\n                const value = response.headers[key];\n                if (isAllowed) {\n                    destination.setHeader(key, value);\n                }\n            }\n            destination.statusCode = statusCode;\n        }\n    }\n    async _setRawBody(from = this) {\n        if (from.readableEnded) {\n            return false;\n        }\n        try {\n            // Errors are emitted via the `error` event\n            const rawBody = await getBuffer(from);\n            // On retry Request is destroyed with no error, therefore the above will successfully resolve.\n            // So in order to check if this was really successfull, we need to check if it has been properly ended.\n            if (!this.isAborted) {\n                this.response.rawBody = rawBody;\n                return true;\n            }\n        }\n        catch { }\n        return false;\n    }\n    async _onResponse(response) {\n        try {\n            await this._onResponseBase(response);\n        }\n        catch (error) {\n            /* istanbul ignore next: better safe than sorry */\n            this._beforeError(error);\n        }\n    }\n    _onRequest(request) {\n        const { options } = this;\n        const { timeout, url } = options;\n        timer(request);\n        if (this.options.http2) {\n            // Unset stream timeout, as the `timeout` option was used only for connection timeout.\n            request.setTimeout(0);\n        }\n        this._cancelTimeouts = timedOut(request, timeout, url);\n        const responseEventName = options.cache ? 'cacheableResponse' : 'response';\n        request.once(responseEventName, (response) => {\n            void this._onResponse(response);\n        });\n        request.once('error', (error) => {\n            this._aborted = true;\n            // Force clean-up, because some packages (e.g. nock) don't do this.\n            request.destroy();\n            error = error instanceof TimedOutTimeoutError ? new TimeoutError(error, this.timings, this) : new RequestError(error.message, error, this);\n            this._beforeError(error);\n        });\n        this._unproxyEvents = proxyEvents(request, this, proxiedRequestEvents);\n        this._request = request;\n        this.emit('uploadProgress', this.uploadProgress);\n        this._sendBody();\n        this.emit('request', request);\n    }\n    async _asyncWrite(chunk) {\n        return new Promise((resolve, reject) => {\n            super.write(chunk, error => {\n                if (error) {\n                    reject(error);\n                    return;\n                }\n                resolve();\n            });\n        });\n    }\n    _sendBody() {\n        // Send body\n        const { body } = this.options;\n        const currentRequest = this.redirectUrls.length === 0 ? this : this._request ?? this;\n        if (is.nodeStream(body)) {\n            body.pipe(currentRequest);\n        }\n        else if (is.generator(body) || is.asyncGenerator(body)) {\n            (async () => {\n                try {\n                    for await (const chunk of body) {\n                        await this._asyncWrite(chunk);\n                    }\n                    super.end();\n                }\n                catch (error) {\n                    this._beforeError(error);\n                }\n            })();\n        }\n        else if (!is.undefined(body)) {\n            this._writeRequest(body, undefined, () => { });\n            currentRequest.end();\n        }\n        else if (this._cannotHaveBody || this._noPipe) {\n            currentRequest.end();\n        }\n    }\n    _prepareCache(cache) {\n        if (!cacheableStore.has(cache)) {\n            const cacheableRequest = new CacheableRequest(((requestOptions, handler) => {\n                const result = requestOptions._request(requestOptions, handler);\n                // TODO: remove this when `cacheable-request` supports async request functions.\n                if (is.promise(result)) {\n                    // We only need to implement the error handler in order to support HTTP2 caching.\n                    // The result will be a promise anyway.\n                    // @ts-expect-error ignore\n                    // eslint-disable-next-line @typescript-eslint/promise-function-async\n                    result.once = (event, handler) => {\n                        if (event === 'error') {\n                            (async () => {\n                                try {\n                                    await result;\n                                }\n                                catch (error) {\n                                    handler(error);\n                                }\n                            })();\n                        }\n                        else if (event === 'abort') {\n                            // The empty catch is needed here in case when\n                            // it rejects before it's `await`ed in `_makeRequest`.\n                            (async () => {\n                                try {\n                                    const request = (await result);\n                                    request.once('abort', handler);\n                                }\n                                catch { }\n                            })();\n                        }\n                        else {\n                            /* istanbul ignore next: safety check */\n                            throw new Error(`Unknown HTTP2 promise event: ${event}`);\n                        }\n                        return result;\n                    };\n                }\n                return result;\n            }), cache);\n            cacheableStore.set(cache, cacheableRequest.request());\n        }\n    }\n    async _createCacheableRequest(url, options) {\n        return new Promise((resolve, reject) => {\n            // TODO: Remove `utils/url-to-options.ts` when `cacheable-request` is fixed\n            Object.assign(options, urlToOptions(url));\n            let request;\n            // TODO: Fix `cacheable-response`. This is ugly.\n            const cacheRequest = cacheableStore.get(options.cache)(options, async (response) => {\n                response._readableState.autoDestroy = false;\n                if (request) {\n                    const fix = () => {\n                        if (response.req) {\n                            response.complete = response.req.res.complete;\n                        }\n                    };\n                    response.prependOnceListener('end', fix);\n                    fix();\n                    (await request).emit('cacheableResponse', response);\n                }\n                resolve(response);\n            });\n            cacheRequest.once('error', reject);\n            cacheRequest.once('request', async (requestOrPromise) => {\n                request = requestOrPromise;\n                resolve(request);\n            });\n        });\n    }\n    async _makeRequest() {\n        const { options } = this;\n        const { headers, username, password } = options;\n        const cookieJar = options.cookieJar;\n        for (const key in headers) {\n            if (is.undefined(headers[key])) {\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete headers[key];\n            }\n            else if (is.null_(headers[key])) {\n                throw new TypeError(`Use \\`undefined\\` instead of \\`null\\` to delete the \\`${key}\\` header`);\n            }\n        }\n        if (options.decompress && is.undefined(headers['accept-encoding'])) {\n            headers['accept-encoding'] = supportsBrotli ? 'gzip, deflate, br' : 'gzip, deflate';\n        }\n        if (username || password) {\n            const credentials = Buffer.from(`${username}:${password}`).toString('base64');\n            headers.authorization = `Basic ${credentials}`;\n        }\n        // Set cookies\n        if (cookieJar) {\n            const cookieString = await cookieJar.getCookieString(options.url.toString());\n            if (is.nonEmptyString(cookieString)) {\n                headers.cookie = cookieString;\n            }\n        }\n        // Reset `prefixUrl`\n        options.prefixUrl = '';\n        let request;\n        for (const hook of options.hooks.beforeRequest) {\n            // eslint-disable-next-line no-await-in-loop\n            const result = await hook(options);\n            if (!is.undefined(result)) {\n                // @ts-expect-error Skip the type mismatch to support abstract responses\n                request = () => result;\n                break;\n            }\n        }\n        if (!request) {\n            request = options.getRequestFunction();\n        }\n        const url = options.url;\n        this._requestOptions = options.createNativeRequestOptions();\n        if (options.cache) {\n            this._requestOptions._request = request;\n            this._requestOptions.cache = options.cache;\n            this._requestOptions.body = options.body;\n            this._prepareCache(options.cache);\n        }\n        // Cache support\n        const fn = options.cache ? this._createCacheableRequest : request;\n        try {\n            // We can't do `await fn(...)`,\n            // because stream `error` event can be emitted before `Promise.resolve()`.\n            let requestOrResponse = fn(url, this._requestOptions);\n            if (is.promise(requestOrResponse)) {\n                requestOrResponse = await requestOrResponse;\n            }\n            // Fallback\n            if (is.undefined(requestOrResponse)) {\n                requestOrResponse = options.getFallbackRequestFunction()(url, this._requestOptions);\n                if (is.promise(requestOrResponse)) {\n                    requestOrResponse = await requestOrResponse;\n                }\n            }\n            if (isClientRequest(requestOrResponse)) {\n                this._onRequest(requestOrResponse);\n            }\n            else if (this.writable) {\n                this.once('finish', () => {\n                    void this._onResponse(requestOrResponse);\n                });\n                this._sendBody();\n            }\n            else {\n                void this._onResponse(requestOrResponse);\n            }\n        }\n        catch (error) {\n            if (error instanceof CacheableCacheError) {\n                throw new CacheError(error, this);\n            }\n            throw error;\n        }\n    }\n    async _error(error) {\n        try {\n            if (error instanceof HTTPError && !this.options.throwHttpErrors) {\n                // This branch can be reached only when using the Promise API\n                // Skip calling the hooks on purpose.\n                // See https://github.com/sindresorhus/got/issues/2103\n            }\n            else {\n                for (const hook of this.options.hooks.beforeError) {\n                    // eslint-disable-next-line no-await-in-loop\n                    error = await hook(error);\n                }\n            }\n        }\n        catch (error_) {\n            error = new RequestError(error_.message, error_, this);\n        }\n        this.destroy(error);\n    }\n    _writeRequest(chunk, encoding, callback) {\n        if (!this._request || this._request.destroyed) {\n            // Probably the `ClientRequest` instance will throw\n            return;\n        }\n        this._request.write(chunk, encoding, (error) => {\n            // The `!destroyed` check is required to prevent `uploadProgress` being emitted after the stream was destroyed\n            if (!error && !this._request.destroyed) {\n                this._uploadedSize += Buffer.byteLength(chunk, encoding);\n                const progress = this.uploadProgress;\n                if (progress.percent < 1) {\n                    this.emit('uploadProgress', progress);\n                }\n            }\n            callback(error);\n        });\n    }\n    /**\n    The remote IP address.\n    */\n    get ip() {\n        return this.socket?.remoteAddress;\n    }\n    /**\n    Indicates whether the request has been aborted or not.\n    */\n    get isAborted() {\n        return this._aborted;\n    }\n    get socket() {\n        return this._request?.socket ?? undefined;\n    }\n    /**\n    Progress event for downloading (receiving a response).\n    */\n    get downloadProgress() {\n        let percent;\n        if (this._responseSize) {\n            percent = this._downloadedSize / this._responseSize;\n        }\n        else if (this._responseSize === this._downloadedSize) {\n            percent = 1;\n        }\n        else {\n            percent = 0;\n        }\n        return {\n            percent,\n            transferred: this._downloadedSize,\n            total: this._responseSize,\n        };\n    }\n    /**\n    Progress event for uploading (sending a request).\n    */\n    get uploadProgress() {\n        let percent;\n        if (this._bodySize) {\n            percent = this._uploadedSize / this._bodySize;\n        }\n        else if (this._bodySize === this._uploadedSize) {\n            percent = 1;\n        }\n        else {\n            percent = 0;\n        }\n        return {\n            percent,\n            transferred: this._uploadedSize,\n            total: this._bodySize,\n        };\n    }\n    /**\n    The object contains the following properties:\n\n    - `start` - Time when the request started.\n    - `socket` - Time when a socket was assigned to the request.\n    - `lookup` - Time when the DNS lookup finished.\n    - `connect` - Time when the socket successfully connected.\n    - `secureConnect` - Time when the socket securely connected.\n    - `upload` - Time when the request finished uploading.\n    - `response` - Time when the request fired `response` event.\n    - `end` - Time when the response fired `end` event.\n    - `error` - Time when the request fired `error` event.\n    - `abort` - Time when the request fired `abort` event.\n    - `phases`\n        - `wait` - `timings.socket - timings.start`\n        - `dns` - `timings.lookup - timings.socket`\n        - `tcp` - `timings.connect - timings.lookup`\n        - `tls` - `timings.secureConnect - timings.connect`\n        - `request` - `timings.upload - (timings.secureConnect || timings.connect)`\n        - `firstByte` - `timings.response - timings.upload`\n        - `download` - `timings.end - timings.response`\n        - `total` - `(timings.end || timings.error || timings.abort) - timings.start`\n\n    If something has not been measured yet, it will be `undefined`.\n\n    __Note__: The time is a `number` representing the milliseconds elapsed since the UNIX epoch.\n    */\n    get timings() {\n        return this._request?.timings;\n    }\n    /**\n    Whether the response was retrieved from the cache.\n    */\n    get isFromCache() {\n        return this._isFromCache;\n    }\n    get reusedSocket() {\n        return this._request?.reusedSocket;\n    }\n}\n"],"mappings":";AAAA,OAAOA,OAAP,MAAoB,cAApB;AACA,SAASC,MAAT,QAAuB,aAAvB;AACA,SAASC,MAAT,QAAuB,aAAvB;AACA,SAASC,GAAT,EAAcC,eAAd,QAAqC,UAArC;AACA,OAAOC,IAAP,IAAeC,cAAf,QAAqC,WAArC;AACA,OAAOC,KAAP,MAAkB,uBAAlB;AACA,OAAOC,gBAAP,IAA2BC,UAAU,IAAIC,mBAAzC,QAAqE,mBAArE;AACA,OAAOC,kBAAP,MAA+B,qBAA/B;AACA,OAAOC,EAAP,MAAe,kBAAf;AACA,SAASC,MAAM,IAAIC,SAAnB,QAAoC,YAApC;AACA,SAASC,eAAT,EAA0BC,UAAU,IAAIC,cAAxC,QAA8D,mBAA9D;AACA,OAAOC,WAAP,MAAwB,0BAAxB;AACA,OAAOF,UAAP,MAAuB,yBAAvB;AACA,OAAOG,WAAP,MAAwB,yBAAxB;AACA,OAAOC,QAAP,IAAmBC,YAAY,IAAIC,oBAAnC,QAA+D,gBAA/D;AACA,OAAOC,YAAP,MAAyB,2BAAzB;AACA,OAAOC,WAAP,MAAwB,yBAAxB;AACA,OAAOC,mBAAP,MAAgC,4BAAhC;AACA,OAAOC,OAAP,MAAoB,cAApB;AACA,SAASC,YAAT,QAA6B,eAA7B;AACA,OAAOC,eAAP,MAA4B,8BAA5B;AACA,OAAOC,eAAP,MAA4B,+BAA5B;AACA,SAASC,YAAT,EAAuBC,SAAvB,EAAkCC,iBAAlC,EAAqDC,SAArD,EAAgEZ,YAAhE,EAA8Ea,WAA9E,EAA2FzB,UAA3F,EAAuG0B,UAAvG,QAA0H,aAA1H;AACA,MAAMC,cAAc,GAAGxB,EAAE,CAACyB,MAAH,CAAUrC,OAAO,CAACsC,QAAR,CAAiBC,MAA3B,CAAvB;AACA,MAAMC,kBAAkB,GAAG,IAAIC,GAAJ,CAAQ,CAAC,KAAD,EAAQ,MAAR,CAAR,CAA3B;AACA,MAAMC,cAAc,GAAG,IAAIlB,WAAJ,EAAvB;AACA,MAAMmB,aAAa,GAAG,IAAIF,GAAJ,CAAQ,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,EAAqB,GAArB,EAA0B,GAA1B,EAA+B,GAA/B,CAAR,CAAtB;AACA,MAAMG,oBAAoB,GAAG,CACzB,QADyB,EAEzB,SAFyB,EAGzB,UAHyB,EAIzB,aAJyB,EAKzB,SALyB,CAA7B;;AAOA,MAAMC,IAAI,GAAG,MAAM,CAAG,CAAtB;;AACA,eAAe,MAAMC,OAAN,SAAsB5C,MAAtB,CAA6B;EACxC6C,WAAW,CAACC,GAAD,EAAMC,OAAN,EAAeC,QAAf,EAAyB;IAChC,MAAM;MACF;MACAC,WAAW,EAAE,KAFX;MAGF;MACAC,aAAa,EAAE;IAJb,CAAN,EADgC,CAOhC;;IACAC,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,aAA5B,EAA2C;MACvCC,UAAU,EAAE,IAD2B;MAEvCC,YAAY,EAAE,IAFyB;MAGvCC,QAAQ,EAAE,IAH6B;MAIvCC,KAAK,EAAE,KAAK;IAJ2B,CAA3C;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,SAA5B,EAAuC;MACnCC,UAAU,EAAE,IADuB;MAEnCC,YAAY,EAAE,IAFqB;MAGnCC,QAAQ,EAAE,IAHyB;MAInCC,KAAK,EAAE,KAAK;IAJuB,CAAvC,EAdgC,CAoBhC;;IACAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,SAA5B,EAAuC;MACnCC,UAAU,EAAE,IADuB;MAEnCC,YAAY,EAAE,IAFqB;MAGnCC,QAAQ,EAAE,IAHyB;MAInCC,KAAK,EAAE,KAAK;IAJuB,CAAvC;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,UAA5B,EAAwC;MACpCC,UAAU,EAAE,IADwB;MAEpCC,YAAY,EAAE,IAFsB;MAGpCC,QAAQ,EAAE,IAH0B;MAIpCC,KAAK,EAAE,KAAK;IAJwB,CAAxC;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,YAA5B,EAA0C;MACtCC,UAAU,EAAE,IAD0B;MAEtCC,YAAY,EAAE,IAFwB;MAGtCC,QAAQ,EAAE,IAH4B;MAItCC,KAAK,EAAE,KAAK;IAJ0B,CAA1C;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,cAA5B,EAA4C;MACxCC,UAAU,EAAE,IAD4B;MAExCC,YAAY,EAAE,IAF0B;MAGxCC,QAAQ,EAAE,IAH8B;MAIxCC,KAAK,EAAE,KAAK;IAJ4B,CAA5C;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,YAA5B,EAA0C;MACtCC,UAAU,EAAE,IAD0B;MAEtCC,YAAY,EAAE,IAFwB;MAGtCC,QAAQ,EAAE,IAH4B;MAItCC,KAAK,EAAE,KAAK;IAJ0B,CAA1C;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,YAA5B,EAA0C;MACtCC,UAAU,EAAE,IAD0B;MAEtCC,YAAY,EAAE,IAFwB;MAGtCC,QAAQ,EAAE,IAH4B;MAItCC,KAAK,EAAE,KAAK;IAJ0B,CAA1C;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,iBAA5B,EAA+C;MAC3CC,UAAU,EAAE,IAD+B;MAE3CC,YAAY,EAAE,IAF6B;MAG3CC,QAAQ,EAAE,IAHiC;MAI3CC,KAAK,EAAE,KAAK;IAJ+B,CAA/C;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,eAA5B,EAA6C;MACzCC,UAAU,EAAE,IAD6B;MAEzCC,YAAY,EAAE,IAF2B;MAGzCC,QAAQ,EAAE,IAH+B;MAIzCC,KAAK,EAAE,KAAK;IAJ6B,CAA7C;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,cAA5B,EAA4C;MACxCC,UAAU,EAAE,IAD4B;MAExCC,YAAY,EAAE,IAF0B;MAGxCC,QAAQ,EAAE,IAH8B;MAIxCC,KAAK,EAAE,KAAK;IAJ4B,CAA5C;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,uBAA5B,EAAqD;MACjDC,UAAU,EAAE,IADqC;MAEjDC,YAAY,EAAE,IAFmC;MAGjDC,QAAQ,EAAE,IAHuC;MAIjDC,KAAK,EAAE,KAAK;IAJqC,CAArD;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,UAA5B,EAAwC;MACpCC,UAAU,EAAE,IADwB;MAEpCC,YAAY,EAAE,IAFsB;MAGpCC,QAAQ,EAAE,IAH0B;MAIpCC,KAAK,EAAE,KAAK;IAJwB,CAAxC;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,eAA5B,EAA6C;MACzCC,UAAU,EAAE,IAD6B;MAEzCC,YAAY,EAAE,IAF2B;MAGzCC,QAAQ,EAAE,IAH+B;MAIzCC,KAAK,EAAE,KAAK;IAJ6B,CAA7C;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,WAA5B,EAAyC;MACrCC,UAAU,EAAE,IADyB;MAErCC,YAAY,EAAE,IAFuB;MAGrCC,QAAQ,EAAE,IAH2B;MAIrCC,KAAK,EAAE,KAAK;IAJyB,CAAzC;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,gBAA5B,EAA8C;MAC1CC,UAAU,EAAE,IAD8B;MAE1CC,YAAY,EAAE,IAF4B;MAG1CC,QAAQ,EAAE,IAHgC;MAI1CC,KAAK,EAAE,KAAK;IAJ8B,CAA9C;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,cAA5B,EAA4C;MACxCC,UAAU,EAAE,IAD4B;MAExCC,YAAY,EAAE,IAF0B;MAGxCC,QAAQ,EAAE,IAH8B;MAIxCC,KAAK,EAAE,KAAK;IAJ4B,CAA5C;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,iBAA5B,EAA+C;MAC3CC,UAAU,EAAE,IAD+B;MAE3CC,YAAY,EAAE,IAF6B;MAG3CC,QAAQ,EAAE,IAHiC;MAI3CC,KAAK,EAAE,KAAK;IAJ+B,CAA/C;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,cAA5B,EAA4C;MACxCC,UAAU,EAAE,IAD4B;MAExCC,YAAY,EAAE,IAF0B;MAGxCC,QAAQ,EAAE,IAH8B;MAIxCC,KAAK,EAAE,KAAK;IAJ4B,CAA5C;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,iBAA5B,EAA+C;MAC3CC,UAAU,EAAE,IAD+B;MAE3CC,YAAY,EAAE,IAF6B;MAG3CC,QAAQ,EAAE,IAHiC;MAI3CC,KAAK,EAAE,KAAK;IAJ+B,CAA/C;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,kBAA5B,EAAgD;MAC5CC,UAAU,EAAE,IADgC;MAE5CC,YAAY,EAAE,IAF8B;MAG5CC,QAAQ,EAAE,IAHkC;MAI5CC,KAAK,EAAE,KAAK;IAJgC,CAAhD;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,iBAA5B,EAA+C;MAC3CC,UAAU,EAAE,IAD+B;MAE3CC,YAAY,EAAE,IAF6B;MAG3CC,QAAQ,EAAE,IAHiC;MAI3CC,KAAK,EAAE,KAAK;IAJ+B,CAA/C;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,UAA5B,EAAwC;MACpCC,UAAU,EAAE,IADwB;MAEpCC,YAAY,EAAE,IAFsB;MAGpCC,QAAQ,EAAE,IAH0B;MAIpCC,KAAK,EAAE,KAAK;IAJwB,CAAxC;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,UAA5B,EAAwC;MACpCC,UAAU,EAAE,IADwB;MAEpCC,YAAY,EAAE,IAFsB;MAGpCC,QAAQ,EAAE,IAH0B;MAIpCC,KAAK,EAAE,KAAK;IAJwB,CAAxC,EAnJgC,CAyJhC;;IACAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,qBAA5B,EAAmD;MAC/CC,UAAU,EAAE,IADmC;MAE/CC,YAAY,EAAE,IAFiC;MAG/CC,QAAQ,EAAE,IAHqC;MAI/CC,KAAK,EAAE,KAAK;IAJmC,CAAnD;IAMA,KAAKC,eAAL,GAAuB,CAAvB;IACA,KAAKC,aAAL,GAAqB,CAArB;IACA,KAAKC,YAAL,GAAoB,KAApB;IACA,KAAKC,qBAAL,GAA6B,IAAIrB,GAAJ,EAA7B;IACA,KAAKsB,eAAL,GAAuB,KAAvB;IACA,KAAKC,cAAL,GAAsBnB,IAAtB;IACA,KAAKoB,YAAL,GAAoB,KAApB;IACA,KAAKC,eAAL,GAAuBrB,IAAvB;IACA,KAAKsB,gBAAL,GAAwBtB,IAAxB;IACA,KAAKuB,KAAL,GAAa,EAAb;IACA,KAAKC,QAAL,GAAgB,KAAhB;IACA,KAAKC,mBAAL,GAA2B,KAA3B;IACA,KAAKC,QAAL,GAAgB,KAAhB;IACA,KAAKC,YAAL,GAAoB,EAApB;IACA,KAAKC,UAAL,GAAkB,CAAlB;IACA,KAAKC,UAAL,GAAkB7B,IAAlB;IACA,KAAK8B,EAAL,CAAQ,MAAR,EAAgBC,MAAM,IAAI;MACtB,IAAIA,MAAM,CAACC,OAAX,EAAoB;QAChBxB,MAAM,CAACyB,MAAP,CAAc,KAAK7B,OAAL,CAAa4B,OAA3B,EAAoCD,MAAM,CAACC,OAA3C;MACH;IACJ,CAJD;IAKA,KAAKF,EAAL,CAAQ,aAAR,EAAuBI,KAAK,IAAI;MAC5B,IAAIA,KAAK,KAAK,OAAV,IAAqB,KAAKC,aAAL,CAAmB,OAAnB,IAA8B,CAAvD,EAA0D;QACtD,MAAM,IAAIC,KAAJ,CAAU,6CAAV,CAAN;MACH;IACJ,CAJD;;IAKA,IAAI;MACA,KAAKhC,OAAL,GAAe,IAAIvB,OAAJ,CAAYsB,GAAZ,EAAiBC,OAAjB,EAA0BC,QAA1B,CAAf;;MACA,IAAI,CAAC,KAAKD,OAAL,CAAaD,GAAlB,EAAuB;QACnB,IAAI,KAAKC,OAAL,CAAaiC,SAAb,KAA2B,EAA/B,EAAmC;UAC/B,MAAM,IAAIC,SAAJ,CAAc,wBAAd,CAAN;QACH;;QACD,KAAKlC,OAAL,CAAaD,GAAb,GAAmB,EAAnB;MACH;;MACD,KAAKoC,UAAL,GAAkB,KAAKnC,OAAL,CAAaD,GAA/B;IACH,CATD,CAUA,OAAOqC,KAAP,EAAc;MACV,MAAM;QAAEpC;MAAF,IAAcoC,KAApB;;MACA,IAAIpC,OAAJ,EAAa;QACT,KAAKA,OAAL,GAAeA,OAAf;MACH;;MACD,KAAKqC,KAAL,GAAa,YAAY;QACrB,KAAKA,KAAL,GAAa,YAAY,CAAG,CAA5B;;QACA,KAAKC,OAAL,CAAaF,KAAb;MACH,CAHD;;MAIA;IACH,CA9M+B,CA+MhC;IACA;;;IACA,MAAM;MAAEG;IAAF,IAAW,KAAKvC,OAAtB;;IACA,IAAIrC,EAAE,CAAC6E,UAAH,CAAcD,IAAd,CAAJ,EAAyB;MACrBA,IAAI,CAACE,IAAL,CAAU,OAAV,EAAmBL,KAAK,IAAI;QACxB,IAAI,KAAKhB,QAAT,EAAmB;UACf,KAAKsB,YAAL,CAAkB,IAAIzD,WAAJ,CAAgBmD,KAAhB,EAAuB,IAAvB,CAAlB;QACH,CAFD,MAGK;UACD,KAAKC,KAAL,GAAa,YAAY;YACrB,KAAKA,KAAL,GAAa,YAAY,CAAG,CAA5B;;YACA,KAAKK,YAAL,CAAkB,IAAIzD,WAAJ,CAAgBmD,KAAhB,EAAuB,IAAvB,CAAlB;UACH,CAHD;QAIH;MACJ,CAVD;IAWH;;IACD,IAAI,KAAKpC,OAAL,CAAa2C,MAAjB,EAAyB;MACrB,MAAMC,KAAK,GAAG,MAAM;QAChB,KAAKN,OAAL,CAAa,IAAIpD,UAAJ,CAAe,IAAf,CAAb;MACH,CAFD;;MAGA,IAAI,KAAKc,OAAL,CAAa2C,MAAb,CAAoBE,OAAxB,EAAiC;QAC7BD,KAAK;MACR,CAFD,MAGK;QACD,KAAK5C,OAAL,CAAa2C,MAAb,CAAoBG,gBAApB,CAAqC,OAArC,EAA8CF,KAA9C;;QACA,KAAK1B,gBAAL,GAAwB,MAAM;UAC1B,KAAKlB,OAAL,CAAa2C,MAAb,CAAoBI,mBAApB,CAAwC,OAAxC,EAAiDH,KAAjD;QACH,CAFD;MAGH;IACJ;EACJ;;EACU,MAALP,KAAK,GAAG;IACV,IAAI,KAAKjB,QAAT,EAAmB;MACf;IACH;;IACD,KAAKA,QAAL,GAAgB,IAAhB;;IACA,IAAI;MACA,MAAM,KAAK4B,aAAL,EAAN;;MACA,IAAI,KAAKC,SAAT,EAAoB;QAChB;MACH;;MACD,MAAM,KAAKC,YAAL,EAAN;;MACA,IAAI,KAAKD,SAAT,EAAoB;QAChB,KAAKE,QAAL,EAAeb,OAAf;QACA;MACH,CATD,CAUA;;;MACA,KAAK,MAAMc,GAAX,IAAkB,KAAKjC,KAAvB,EAA8B;QAC1BiC,GAAG;MACN,CAbD,CAcA;;;MACA,KAAKjC,KAAL,CAAWkC,MAAX,GAAoB,CAApB;MACA,KAAKhC,mBAAL,GAA2B,IAA3B;IACH,CAjBD,CAkBA,OAAOe,KAAP,EAAc;MACV,KAAKM,YAAL,CAAkBN,KAAlB;IACH;EACJ;;EACDM,YAAY,CAACN,KAAD,EAAQ;IAChB,IAAI,KAAKxB,YAAT,EAAuB;MACnB;IACH;;IACD,MAAM;MAAE0C,QAAF;MAAYtD;IAAZ,IAAwB,IAA9B;IACA,MAAMuD,YAAY,GAAG,KAAK/B,UAAL,IAAmBY,KAAK,CAACoB,IAAN,KAAe,YAAf,GAA8B,CAA9B,GAAkC,CAArD,CAArB;IACA,KAAK5C,YAAL,GAAoB,IAApB;;IACA,IAAI,EAAEwB,KAAK,YAAYvD,YAAnB,CAAJ,EAAsC;MAClCuD,KAAK,GAAG,IAAIvD,YAAJ,CAAiBuD,KAAK,CAACqB,OAAvB,EAAgCrB,KAAhC,EAAuC,IAAvC,CAAR;IACH;;IACD,MAAMsB,UAAU,GAAGtB,KAAnB;IACA,KAAK,CAAC,YAAY;MACd;MACA;MACA;MACA;MACA;MACA;MACA,IAAIkB,QAAQ,EAAEK,QAAV,IAAsB,CAACL,QAAQ,CAACM,OAAhC,IAA2C,CAAC,KAAKT,QAAL,EAAeU,MAAf,EAAuBZ,SAAvE,EAAkF;QAC9E;QACAK,QAAQ,CAACQ,WAAT,CAAqB,KAAKC,gBAA1B;QACA,MAAMC,OAAO,GAAG,MAAM,KAAKC,WAAL,CAAiBX,QAAjB,CAAtB;;QACA,IAAIU,OAAJ,EAAa;UACTV,QAAQ,CAACf,IAAT,GAAgBe,QAAQ,CAACM,OAAT,CAAiBM,QAAjB,EAAhB;QACH;MACJ;;MACD,IAAI,KAAKnC,aAAL,CAAmB,OAAnB,MAAgC,CAApC,EAAuC;QACnC,IAAIoC,OAAJ;;QACA,IAAI;UACA,IAAIC,UAAJ;;UACA,IAAId,QAAQ,IAAI,iBAAiBA,QAAQ,CAAC1B,OAA1C,EAAmD;YAC/CwC,UAAU,GAAGC,MAAM,CAACf,QAAQ,CAAC1B,OAAT,CAAiB,aAAjB,CAAD,CAAnB;;YACA,IAAIyC,MAAM,CAACC,KAAP,CAAaF,UAAb,CAAJ,EAA8B;cAC1BA,UAAU,GAAGG,IAAI,CAACC,KAAL,CAAWlB,QAAQ,CAAC1B,OAAT,CAAiB,aAAjB,CAAX,IAA8C2C,IAAI,CAACE,GAAL,EAA3D;;cACA,IAAIL,UAAU,IAAI,CAAlB,EAAqB;gBACjBA,UAAU,GAAG,CAAb;cACH;YACJ,CALD,MAMK;cACDA,UAAU,IAAI,IAAd;YACH;UACJ;;UACD,MAAMM,YAAY,GAAG1E,OAAO,CAAC2E,KAA7B;UACAR,OAAO,GAAG,MAAMO,YAAY,CAACE,cAAb,CAA4B;YACxCrB,YADwC;YAExCmB,YAFwC;YAGxCtC,KAAK,EAAEsB,UAHiC;YAIxCU,UAJwC;YAKxCS,aAAa,EAAErG,mBAAmB,CAAC;cAC/B+E,YAD+B;cAE/BmB,YAF+B;cAG/BtC,KAAK,EAAEsB,UAHwB;cAI/BU,UAJ+B;cAK/BS,aAAa,EAAEH,YAAY,CAACI,aAAb,IAA8B9E,OAAO,CAAC+E,OAAR,CAAgBC,OAA9C,IAAyDX,MAAM,CAACY;YALhD,CAAD;UALM,CAA5B,CAAhB;QAaH,CA5BD,CA6BA,OAAOC,MAAP,EAAe;UACX,KAAK,KAAKC,MAAL,CAAY,IAAItG,YAAJ,CAAiBqG,MAAM,CAACzB,OAAxB,EAAiCyB,MAAjC,EAAyC,IAAzC,CAAZ,CAAL;UACA;QACH;;QACD,IAAIf,OAAJ,EAAa;UACT,MAAM,IAAIiB,OAAJ,CAAYC,OAAO,IAAI;YACzB,MAAMN,OAAO,GAAGO,UAAU,CAACD,OAAD,EAAUlB,OAAV,CAA1B;;YACA,KAAK1C,UAAL,GAAkB,MAAM;cACpB8D,YAAY,CAACR,OAAD,CAAZ;cACAM,OAAO;YACV,CAHD;UAIH,CANK,CAAN,CADS,CAQT;;UACA,IAAI,KAAKpC,SAAT,EAAoB;YAChB;UACH;;UACD,IAAI;YACA,KAAK,MAAMuC,IAAX,IAAmB,KAAKxF,OAAL,CAAayF,KAAb,CAAmBC,WAAtC,EAAmD;cAC/C;cACA,MAAMF,IAAI,CAAC9B,UAAD,EAAa,KAAKlC,UAAL,GAAkB,CAA/B,CAAV;YACH;UACJ,CALD,CAMA,OAAO0D,MAAP,EAAe;YACX,KAAK,KAAKC,MAAL,CAAY,IAAItG,YAAJ,CAAiBqG,MAAM,CAACzB,OAAxB,EAAiCrB,KAAjC,EAAwC,IAAxC,CAAZ,CAAL;YACA;UACH,CArBQ,CAsBT;;;UACA,IAAI,KAAKa,SAAT,EAAoB;YAChB;UACH;;UACD,KAAKX,OAAL;UACA,KAAKqD,IAAL,CAAU,OAAV,EAAmB,KAAKnE,UAAL,GAAkB,CAArC,EAAwCY,KAAxC,EAAgDwD,cAAD,IAAoB;YAC/D,MAAMZ,OAAO,GAAG,IAAInF,OAAJ,CAAYG,OAAO,CAACD,GAApB,EAAyB6F,cAAzB,EAAyC5F,OAAzC,CAAhB;YACAgF,OAAO,CAACxD,UAAR,GAAqB,KAAKA,UAAL,GAAkB,CAAvC;YACAzE,OAAO,CAAC8I,QAAR,CAAiB,MAAM;cACnB,KAAKb,OAAO,CAAC3C,KAAR,EAAL;YACH,CAFD;YAGA,OAAO2C,OAAP;UACH,CAPD;UAQA;QACH;MACJ;;MACD,KAAK,KAAKG,MAAL,CAAYzB,UAAZ,CAAL;IACH,CAzFI,GAAL;EA0FH;;EACDoC,KAAK,GAAG;IACJ,KAAK9E,YAAL,GAAoB,IAApB;IACA,MAAM;MAAEsC;IAAF,IAAe,IAArB;;IACA,IAAIA,QAAQ,IAAI,CAAC,KAAK1C,YAAtB,EAAoC;MAChC;MACA;MACA,IAAI0C,QAAQ,CAACyC,cAAb,EAA6B;QACzB,KAAK/E,YAAL,GAAoB,KAApB;MACH;;MACD,IAAIgF,IAAJ;;MACA,OAAO,CAACA,IAAI,GAAG1C,QAAQ,CAAC2C,IAAT,EAAR,MAA6B,IAApC,EAA0C;QACtC,KAAKvF,eAAL,IAAwBsF,IAAI,CAAC3C,MAA7B,CADsC,CACD;;QACrC,MAAM6C,QAAQ,GAAG,KAAKC,gBAAtB;;QACA,IAAID,QAAQ,CAACE,OAAT,GAAmB,CAAvB,EAA0B;UACtB,KAAKT,IAAL,CAAU,kBAAV,EAA8BO,QAA9B;QACH;;QACD,KAAKG,IAAL,CAAUL,IAAV;MACH;IACJ;EACJ;;EACDM,MAAM,CAACC,KAAD,EAAQC,QAAR,EAAkBC,QAAlB,EAA4B;IAC9B,MAAMC,KAAK,GAAG,MAAM;MAChB,KAAKC,aAAL,CAAmBJ,KAAnB,EAA0BC,QAA1B,EAAoCC,QAApC;IACH,CAFD;;IAGA,IAAI,KAAKpF,mBAAT,EAA8B;MAC1BqF,KAAK;IACR,CAFD,MAGK;MACD,KAAKvF,KAAL,CAAWkF,IAAX,CAAgBK,KAAhB;IACH;EACJ;;EACDE,MAAM,CAACH,QAAD,EAAW;IACb,MAAMI,UAAU,GAAG,MAAM;MACrB;MACA;MACA,IAAI,CAAC,KAAK1D,QAAN,IAAkB,KAAKA,QAAL,CAAcF,SAApC,EAA+C;QAC3CwD,QAAQ;QACR;MACH;;MACD,KAAKtD,QAAL,CAAc2D,GAAd,CAAmB1E,KAAD,IAAW;QACzB;QACA;QACA,IAAI,KAAKe,QAAL,CAAc4D,cAAd,EAA8BC,OAAlC,EAA2C;UACvC;QACH;;QACD,IAAI,CAAC5E,KAAL,EAAY;UACR,KAAK6E,SAAL,GAAiB,KAAKtG,aAAtB;UACA,KAAKgF,IAAL,CAAU,gBAAV,EAA4B,KAAKuB,cAAjC;;UACA,KAAK/D,QAAL,CAAcwC,IAAd,CAAmB,iBAAnB;QACH;;QACDc,QAAQ,CAACrE,KAAD,CAAR;MACH,CAZD;IAaH,CApBD;;IAqBA,IAAI,KAAKf,mBAAT,EAA8B;MAC1BwF,UAAU;IACb,CAFD,MAGK;MACD,KAAK1F,KAAL,CAAWkF,IAAX,CAAgBQ,UAAhB;IACH;EACJ;;EACDM,QAAQ,CAAC/E,KAAD,EAAQqE,QAAR,EAAkB;IACtB,KAAK7F,YAAL,GAAoB,IAApB;;IACA,KAAKyB,KAAL,GAAa,YAAY,CAAG,CAA5B,CAFsB,CAGtB;;;IACA,KAAKZ,UAAL;;IACA,KAAKR,eAAL;;IACA,KAAKC,gBAAL;;IACA,IAAI,KAAKlB,OAAT,EAAkB;MACd,MAAM;QAAEuC;MAAF,IAAW,KAAKvC,OAAtB;;MACA,IAAIrC,EAAE,CAAC6E,UAAH,CAAcD,IAAd,CAAJ,EAAyB;QACrBA,IAAI,CAACD,OAAL;MACH;IACJ;;IACD,IAAI,KAAKa,QAAT,EAAmB;MACf,KAAKA,QAAL,CAAcb,OAAd;IACH;;IACD,IAAIF,KAAK,KAAK,IAAV,IAAkB,CAACzE,EAAE,CAACyJ,SAAH,CAAahF,KAAb,CAAnB,IAA0C,EAAEA,KAAK,YAAYvD,YAAnB,CAA9C,EAAgF;MAC5EuD,KAAK,GAAG,IAAIvD,YAAJ,CAAiBuD,KAAK,CAACqB,OAAvB,EAAgCrB,KAAhC,EAAuC,IAAvC,CAAR;IACH;;IACDqE,QAAQ,CAACrE,KAAD,CAAR;EACH;;EACDiF,IAAI,CAACC,WAAD,EAActH,OAAd,EAAuB;IACvB,IAAIsH,WAAW,YAAYjK,cAA3B,EAA2C;MACvC,KAAKwD,qBAAL,CAA2B0G,GAA3B,CAA+BD,WAA/B;IACH;;IACD,OAAO,MAAMD,IAAN,CAAWC,WAAX,EAAwBtH,OAAxB,CAAP;EACH;;EACDwH,MAAM,CAACF,WAAD,EAAc;IAChB,IAAIA,WAAW,YAAYjK,cAA3B,EAA2C;MACvC,KAAKwD,qBAAL,CAA2B4G,MAA3B,CAAkCH,WAAlC;IACH;;IACD,MAAME,MAAN,CAAaF,WAAb;IACA,OAAO,IAAP;EACH;;EACkB,MAAbtE,aAAa,GAAG;IAClB,MAAM;MAAEhD;IAAF,IAAc,IAApB;IACA,MAAM;MAAE4B;IAAF,IAAc5B,OAApB;IACA,MAAM0H,MAAM,GAAG,CAAC/J,EAAE,CAACyJ,SAAH,CAAapH,OAAO,CAAC2H,IAArB,CAAhB,CAHkB,CAIlB;;IACA,MAAMC,MAAM,GAAG,CAACjK,EAAE,CAACyJ,SAAH,CAAapH,OAAO,CAAC6H,IAArB,CAAhB;IACA,MAAMC,MAAM,GAAG,CAACnK,EAAE,CAACyJ,SAAH,CAAapH,OAAO,CAACuC,IAArB,CAAhB;IACA,MAAMwF,cAAc,GAAGxI,kBAAkB,CAACyI,GAAnB,CAAuBhI,OAAO,CAACiI,MAA/B,KAA0C,EAAEjI,OAAO,CAACiI,MAAR,KAAmB,KAAnB,IAA4BjI,OAAO,CAACkI,YAAtC,CAAjE;IACA,KAAKpH,eAAL,GAAuBiH,cAAvB;;IACA,IAAIL,MAAM,IAAIE,MAAV,IAAoBE,MAAxB,EAAgC;MAC5B,IAAIC,cAAJ,EAAoB;QAChB,MAAM,IAAI7F,SAAJ,CAAe,SAAQlC,OAAO,CAACiI,MAAO,sCAAtC,CAAN;MACH,CAH2B,CAI5B;;;MACA,MAAME,aAAa,GAAG,CAACxK,EAAE,CAACyB,MAAH,CAAUwC,OAAO,CAAC,cAAD,CAAjB,CAAvB;;MACA,IAAIkG,MAAJ,EAAY;QACR;QACA,IAAI9J,cAAc,CAACgC,OAAO,CAACuC,IAAT,CAAlB,EAAkC;UAC9B,MAAM6F,OAAO,GAAG,IAAItK,eAAJ,CAAoBkC,OAAO,CAACuC,IAA5B,CAAhB;;UACA,IAAI4F,aAAJ,EAAmB;YACfvG,OAAO,CAAC,cAAD,CAAP,GAA0BwG,OAAO,CAACxG,OAAR,CAAgB,cAAhB,CAA1B;UACH;;UACD,IAAI,oBAAoBwG,OAAO,CAACxG,OAAhC,EAAyC;YACrCA,OAAO,CAAC,gBAAD,CAAP,GAA4BwG,OAAO,CAACxG,OAAR,CAAgB,gBAAhB,CAA5B;UACH;;UACD5B,OAAO,CAACuC,IAAR,GAAe6F,OAAO,CAACC,MAAR,EAAf;QACH,CAXO,CAYR;;;QACA,IAAItK,UAAU,CAACiC,OAAO,CAACuC,IAAT,CAAV,IAA4B4F,aAAhC,EAA+C;UAC3CvG,OAAO,CAAC,cAAD,CAAP,GAA2B,iCAAgC5B,OAAO,CAACuC,IAAR,CAAa+F,WAAb,EAA2B,EAAtF;QACH;MACJ,CAhBD,MAiBK,IAAIZ,MAAJ,EAAY;QACb,IAAIS,aAAJ,EAAmB;UACfvG,OAAO,CAAC,cAAD,CAAP,GAA0B,mCAA1B;QACH;;QACD,MAAM;UAAE+F;QAAF,IAAW3H,OAAjB;QACAA,OAAO,CAAC2H,IAAR,GAAeP,SAAf;QACApH,OAAO,CAACuC,IAAR,GAAgB,IAAIpF,eAAJ,CAAoBwK,IAApB,CAAD,CAA4BzD,QAA5B,EAAf;MACH,CAPI,MAQA;QACD,IAAIiE,aAAJ,EAAmB;UACfvG,OAAO,CAAC,cAAD,CAAP,GAA0B,kBAA1B;QACH;;QACD,MAAM;UAAEiG;QAAF,IAAW7H,OAAjB;QACAA,OAAO,CAAC6H,IAAR,GAAeT,SAAf;QACApH,OAAO,CAACuC,IAAR,GAAevC,OAAO,CAACuI,aAAR,CAAsBV,IAAtB,CAAf;MACH;;MACD,MAAMW,cAAc,GAAG,MAAMvK,WAAW,CAAC+B,OAAO,CAACuC,IAAT,EAAevC,OAAO,CAAC4B,OAAvB,CAAxC,CAvC4B,CAwC5B;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;MACA,IAAIjE,EAAE,CAACyJ,SAAH,CAAaxF,OAAO,CAAC,gBAAD,CAApB,KAA2CjE,EAAE,CAACyJ,SAAH,CAAaxF,OAAO,CAAC,mBAAD,CAApB,CAA3C,IAAyF,CAACmG,cAA1F,IAA4G,CAACpK,EAAE,CAACyJ,SAAH,CAAaoB,cAAb,CAAjH,EAA+I;QAC3I5G,OAAO,CAAC,gBAAD,CAAP,GAA4B6G,MAAM,CAACD,cAAD,CAAlC;MACH;IACJ;;IACD,IAAIxI,OAAO,CAAC0I,YAAR,KAAyB,MAAzB,IAAmC,EAAE,YAAY1I,OAAO,CAAC4B,OAAtB,CAAvC,EAAuE;MACnE5B,OAAO,CAAC4B,OAAR,CAAgB+G,MAAhB,GAAyB,kBAAzB;IACH;;IACD,KAAK1B,SAAL,GAAiB5C,MAAM,CAACzC,OAAO,CAAC,gBAAD,CAAR,CAAN,IAAqCwF,SAAtD;EACH;;EACoB,MAAfwB,eAAe,CAACtF,QAAD,EAAW;IAC5B;IACA,IAAI,KAAKuF,SAAT,EAAoB;MAChB;IACH;;IACD,MAAM;MAAE7I;IAAF,IAAc,IAApB;IACA,MAAM;MAAED;IAAF,IAAUC,OAAhB;IACA,KAAK8I,eAAL,GAAuBxF,QAAvB;;IACA,IAAItD,OAAO,CAAC+I,UAAZ,EAAwB;MACpBzF,QAAQ,GAAG5F,kBAAkB,CAAC4F,QAAD,CAA7B;IACH;;IACD,MAAM0F,UAAU,GAAG1F,QAAQ,CAAC0F,UAA5B;IACA,MAAMC,aAAa,GAAG3F,QAAtB;IACA2F,aAAa,CAACC,aAAd,GAA8BD,aAAa,CAACC,aAAd,IAA+B9L,IAAI,CAAC+L,YAAL,CAAkBH,UAAlB,CAA7D;IACAC,aAAa,CAAClJ,GAAd,GAAoBC,OAAO,CAACD,GAAR,CAAYmE,QAAZ,EAApB;IACA+E,aAAa,CAAC9G,UAAd,GAA2B,KAAKA,UAAhC;IACA8G,aAAa,CAAC1H,YAAd,GAA6B,KAAKA,YAAlC;IACA0H,aAAa,CAACjE,OAAd,GAAwB,IAAxB;IACAiE,aAAa,CAACG,WAAd,GAA4B,KAAKN,eAAL,CAAqBO,SAArB,IAAkC,KAA9D;IACAJ,aAAa,CAACK,EAAd,GAAmB,KAAKA,EAAxB;IACAL,aAAa,CAACzH,UAAd,GAA2B,KAAKA,UAAhC;IACAyH,aAAa,CAACM,EAAd,GAAmB7K,YAAY,CAACuK,aAAD,CAA/B;IACA,KAAKO,YAAL,GAAoBP,aAAa,CAACG,WAAlC;IACA,KAAKK,aAAL,GAAqBpF,MAAM,CAACf,QAAQ,CAAC1B,OAAT,CAAiB,gBAAjB,CAAD,CAAN,IAA8CwF,SAAnE;IACA,KAAK9D,QAAL,GAAgB2F,aAAhB;IACA3F,QAAQ,CAACb,IAAT,CAAc,KAAd,EAAqB,MAAM;MACvB,KAAKgH,aAAL,GAAqB,KAAK/I,eAA1B;MACA,KAAKiF,IAAL,CAAU,kBAAV,EAA8B,KAAKQ,gBAAnC;IACH,CAHD;IAIA7C,QAAQ,CAACb,IAAT,CAAc,OAAd,EAAwBL,KAAD,IAAW;MAC9B,KAAKd,QAAL,GAAgB,IAAhB,CAD8B,CAE9B;MACA;;MACAgC,QAAQ,CAAChB,OAAT;;MACA,KAAKI,YAAL,CAAkB,IAAI5D,SAAJ,CAAcsD,KAAd,EAAqB,IAArB,CAAlB;IACH,CAND;IAOAkB,QAAQ,CAACb,IAAT,CAAc,SAAd,EAAyB,MAAM;MAC3B,KAAKnB,QAAL,GAAgB,IAAhB;;MACA,KAAKoB,YAAL,CAAkB,IAAI5D,SAAJ,CAAc;QAC5B0E,IAAI,EAAE,OADsB;QAE5BC,OAAO,EAAE,oCAFmB;QAG5BiG,IAAI,EAAE;MAHsB,CAAd,EAIf,IAJe,CAAlB;IAKH,CAPD;IAQA,KAAK/D,IAAL,CAAU,kBAAV,EAA8B,KAAKQ,gBAAnC;IACA,MAAMwD,UAAU,GAAGrG,QAAQ,CAAC1B,OAAT,CAAiB,YAAjB,CAAnB;;IACA,IAAIjE,EAAE,CAACiM,MAAH,CAAU5J,OAAO,CAAC6J,SAAlB,KAAgCF,UAApC,EAAgD;MAC5C,IAAIG,QAAQ,GAAGH,UAAU,CAACI,GAAX,CAAe,MAAOC,SAAP,IAAqBhK,OAAO,CAAC6J,SAAR,CAAkBI,SAAlB,CAA4BD,SAA5B,EAAuCjK,GAAG,CAACmE,QAAJ,EAAvC,CAApC,CAAf;;MACA,IAAIlE,OAAO,CAACkK,oBAAZ,EAAkC;QAC9BJ,QAAQ,GAAGA,QAAQ,CAACC,GAAT,CAAa,MAAOI,OAAP,IAAmB;UACvC,IAAI;YACA,MAAMA,OAAN;UACH,CAFD,CAGA,MAAM,CAAG;QACZ,CALU,CAAX;MAMH;;MACD,IAAI;QACA,MAAM/E,OAAO,CAACgF,GAAR,CAAYN,QAAZ,CAAN;MACH,CAFD,CAGA,OAAO1H,KAAP,EAAc;QACV,KAAKM,YAAL,CAAkBN,KAAlB;;QACA;MACH;IACJ,CA/D2B,CAgE5B;;;IACA,IAAI,KAAKyG,SAAT,EAAoB;MAChB;IACH;;IACD,IAAI7I,OAAO,CAACqK,cAAR,IAA0B/G,QAAQ,CAAC1B,OAAT,CAAiB0I,QAA3C,IAAuD5K,aAAa,CAACsI,GAAd,CAAkBgB,UAAlB,CAA3D,EAA0F;MACtF;MACA;MACA;MACA1F,QAAQ,CAACiH,MAAT;;MACA,KAAKtJ,eAAL;;MACA,KAAKF,cAAL;;MACA,IAAI,KAAKQ,YAAL,CAAkB8B,MAAlB,IAA4BrD,OAAO,CAACwK,YAAxC,EAAsD;QAClD,KAAK9H,YAAL,CAAkB,IAAI3D,iBAAJ,CAAsB,IAAtB,CAAlB;;QACA;MACH;;MACD,KAAKoE,QAAL,GAAgBiE,SAAhB;MACA,MAAMxB,cAAc,GAAG,IAAInH,OAAJ,CAAY2I,SAAZ,EAAuBA,SAAvB,EAAkC,KAAKpH,OAAvC,CAAvB;MACA,MAAMyK,kBAAkB,GAAGzB,UAAU,KAAK,GAAf,IAAsBpD,cAAc,CAACqC,MAAf,KAA0B,KAAhD,IAAyDrC,cAAc,CAACqC,MAAf,KAA0B,MAA9G;MACA,MAAMyC,UAAU,GAAG1B,UAAU,KAAK,GAAf,IAAsBA,UAAU,KAAK,GAAxD;MACA,MAAM2B,gBAAgB,GAAG/E,cAAc,CAACgF,eAAf,IAAkCF,UAA3D;;MACA,IAAID,kBAAkB,IAAIE,gBAA1B,EAA4C;QACxC/E,cAAc,CAACqC,MAAf,GAAwB,KAAxB;QACArC,cAAc,CAACrD,IAAf,GAAsB6E,SAAtB;QACAxB,cAAc,CAACiC,IAAf,GAAsBT,SAAtB;QACAxB,cAAc,CAAC+B,IAAf,GAAsBP,SAAtB;QACA,OAAOxB,cAAc,CAAChE,OAAf,CAAuB,gBAAvB,CAAP;MACH;;MACD,IAAI;QACA;QACA,MAAMiJ,cAAc,GAAG7N,MAAM,CAAC8N,IAAP,CAAYxH,QAAQ,CAAC1B,OAAT,CAAiB0I,QAA7B,EAAuC,QAAvC,EAAiDpG,QAAjD,EAAvB;QACA,MAAM6G,WAAW,GAAG,IAAI7N,GAAJ,CAAQ2N,cAAR,EAAwB9K,GAAxB,CAApB;;QACA,IAAI,CAACnB,eAAe,CAACmB,GAAD,CAAhB,IAAyBnB,eAAe,CAACmM,WAAD,CAA5C,EAA2D;UACvD,KAAKrI,YAAL,CAAkB,IAAI7D,YAAJ,CAAiB,gCAAjB,EAAmD,EAAnD,EAAuD,IAAvD,CAAlB;;UACA;QACH,CAPD,CAQA;;;QACA,IAAIkM,WAAW,CAACC,QAAZ,KAAyBjL,GAAG,CAACiL,QAA7B,IAAyCD,WAAW,CAACE,IAAZ,KAAqBlL,GAAG,CAACkL,IAAtE,EAA4E;UACxE,IAAI,UAAUrF,cAAc,CAAChE,OAA7B,EAAsC;YAClC,OAAOgE,cAAc,CAAChE,OAAf,CAAuBsJ,IAA9B;UACH;;UACD,IAAI,YAAYtF,cAAc,CAAChE,OAA/B,EAAwC;YACpC,OAAOgE,cAAc,CAAChE,OAAf,CAAuBuJ,MAA9B;UACH;;UACD,IAAI,mBAAmBvF,cAAc,CAAChE,OAAtC,EAA+C;YAC3C,OAAOgE,cAAc,CAAChE,OAAf,CAAuBwJ,aAA9B;UACH;;UACD,IAAIxF,cAAc,CAACyF,QAAf,IAA2BzF,cAAc,CAAC0F,QAA9C,EAAwD;YACpD1F,cAAc,CAACyF,QAAf,GAA0B,EAA1B;YACAzF,cAAc,CAAC0F,QAAf,GAA0B,EAA1B;UACH;QACJ,CAdD,MAeK;UACDP,WAAW,CAACM,QAAZ,GAAuBzF,cAAc,CAACyF,QAAtC;UACAN,WAAW,CAACO,QAAZ,GAAuB1F,cAAc,CAAC0F,QAAtC;QACH;;QACD,KAAK/J,YAAL,CAAkB8E,IAAlB,CAAuB0E,WAAvB;QACAnF,cAAc,CAAC3D,SAAf,GAA2B,EAA3B;QACA2D,cAAc,CAAC7F,GAAf,GAAqBgL,WAArB;;QACA,KAAK,MAAMvF,IAAX,IAAmBI,cAAc,CAACH,KAAf,CAAqB8F,cAAxC,EAAwD;UACpD;UACA,MAAM/F,IAAI,CAACI,cAAD,EAAiBqD,aAAjB,CAAV;QACH;;QACD,KAAKtD,IAAL,CAAU,UAAV,EAAsBC,cAAtB,EAAsCqD,aAAtC;QACA,KAAKjJ,OAAL,GAAe4F,cAAf;QACA,MAAM,KAAK1C,YAAL,EAAN;MACH,CAtCD,CAuCA,OAAOd,KAAP,EAAc;QACV,KAAKM,YAAL,CAAkBN,KAAlB;;QACA;MACH;;MACD;IACH,CAvI2B,CAwI5B;IACA;IACA;IACA;;;IACA,IAAIpC,OAAO,CAACwL,QAAR,IAAoBxL,OAAO,CAACyL,eAA5B,IAA+C,CAAC/M,YAAY,CAACuK,aAAD,CAAhE,EAAiF;MAC7E,KAAKvG,YAAL,CAAkB,IAAI1D,SAAJ,CAAciK,aAAd,CAAlB;;MACA;IACH;;IACD3F,QAAQ,CAAC5B,EAAT,CAAY,UAAZ,EAAwB,MAAM;MAC1B,IAAI,KAAKV,YAAT,EAAuB;QACnB,KAAK8E,KAAL;MACH;IACJ,CAJD;IAKA,KAAKpE,EAAL,CAAQ,QAAR,EAAkB,MAAM;MACpB4B,QAAQ,CAACiH,MAAT;IACH,CAFD;IAGA,KAAK7I,EAAL,CAAQ,OAAR,EAAiB,MAAM;MACnB4B,QAAQ,CAACoI,KAAT;IACH,CAFD;IAGApI,QAAQ,CAACb,IAAT,CAAc,KAAd,EAAqB,MAAM;MACvB,KAAK4D,IAAL,CAAU,IAAV;IACH,CAFD;;IAGA,IAAI,KAAKsF,OAAT,EAAkB;MACd,MAAM3H,OAAO,GAAG,MAAM,KAAKC,WAAL,EAAtB;;MACA,IAAID,OAAJ,EAAa;QACT,KAAK2B,IAAL,CAAU,UAAV,EAAsBrC,QAAtB;MACH;;MACD;IACH;;IACD,KAAKqC,IAAL,CAAU,UAAV,EAAsBrC,QAAtB;;IACA,KAAK,MAAMgE,WAAX,IAA0B,KAAKzG,qBAA/B,EAAsD;MAClD,IAAIyG,WAAW,CAACsE,WAAhB,EAA6B;QACzB;MACH,CAHiD,CAIlD;;;MACA,KAAK,MAAMC,GAAX,IAAkBvI,QAAQ,CAAC1B,OAA3B,EAAoC;QAChC,MAAMkK,SAAS,GAAG9L,OAAO,CAAC+I,UAAR,GAAqB8C,GAAG,KAAK,kBAA7B,GAAkD,IAApE;QACA,MAAMpL,KAAK,GAAG6C,QAAQ,CAAC1B,OAAT,CAAiBiK,GAAjB,CAAd;;QACA,IAAIC,SAAJ,EAAe;UACXxE,WAAW,CAACyE,SAAZ,CAAsBF,GAAtB,EAA2BpL,KAA3B;QACH;MACJ;;MACD6G,WAAW,CAAC0B,UAAZ,GAAyBA,UAAzB;IACH;EACJ;;EACgB,MAAX/E,WAAW,CAAC6G,IAAI,GAAG,IAAR,EAAc;IAC3B,IAAIA,IAAI,CAACkB,aAAT,EAAwB;MACpB,OAAO,KAAP;IACH;;IACD,IAAI;MACA;MACA,MAAMpI,OAAO,GAAG,MAAM/F,SAAS,CAACiN,IAAD,CAA/B,CAFA,CAGA;MACA;;MACA,IAAI,CAAC,KAAKjC,SAAV,EAAqB;QACjB,KAAKvF,QAAL,CAAcM,OAAd,GAAwBA,OAAxB;QACA,OAAO,IAAP;MACH;IACJ,CATD,CAUA,MAAM,CAAG;;IACT,OAAO,KAAP;EACH;;EACgB,MAAXqI,WAAW,CAAC3I,QAAD,EAAW;IACxB,IAAI;MACA,MAAM,KAAKsF,eAAL,CAAqBtF,QAArB,CAAN;IACH,CAFD,CAGA,OAAOlB,KAAP,EAAc;MACV;MACA,KAAKM,YAAL,CAAkBN,KAAlB;IACH;EACJ;;EACD8J,UAAU,CAAClH,OAAD,EAAU;IAChB,MAAM;MAAEhF;IAAF,IAAc,IAApB;IACA,MAAM;MAAE+E,OAAF;MAAWhF;IAAX,IAAmBC,OAAzB;IACA1C,KAAK,CAAC0H,OAAD,CAAL;;IACA,IAAI,KAAKhF,OAAL,CAAamM,KAAjB,EAAwB;MACpB;MACAnH,OAAO,CAACM,UAAR,CAAmB,CAAnB;IACH;;IACD,KAAKrE,eAAL,GAAuB9C,QAAQ,CAAC6G,OAAD,EAAUD,OAAV,EAAmBhF,GAAnB,CAA/B;IACA,MAAMqM,iBAAiB,GAAGpM,OAAO,CAACqM,KAAR,GAAgB,mBAAhB,GAAsC,UAAhE;IACArH,OAAO,CAACvC,IAAR,CAAa2J,iBAAb,EAAiC9I,QAAD,IAAc;MAC1C,KAAK,KAAK2I,WAAL,CAAiB3I,QAAjB,CAAL;IACH,CAFD;IAGA0B,OAAO,CAACvC,IAAR,CAAa,OAAb,EAAuBL,KAAD,IAAW;MAC7B,KAAKd,QAAL,GAAgB,IAAhB,CAD6B,CAE7B;;MACA0D,OAAO,CAAC1C,OAAR;MACAF,KAAK,GAAGA,KAAK,YAAY/D,oBAAjB,GAAwC,IAAID,YAAJ,CAAiBgE,KAAjB,EAAwB,KAAKkK,OAA7B,EAAsC,IAAtC,CAAxC,GAAsF,IAAIzN,YAAJ,CAAiBuD,KAAK,CAACqB,OAAvB,EAAgCrB,KAAhC,EAAuC,IAAvC,CAA9F;;MACA,KAAKM,YAAL,CAAkBN,KAAlB;IACH,CAND;IAOA,KAAKrB,cAAL,GAAsB7C,WAAW,CAAC8G,OAAD,EAAU,IAAV,EAAgBrF,oBAAhB,CAAjC;IACA,KAAKwD,QAAL,GAAgB6B,OAAhB;IACA,KAAKW,IAAL,CAAU,gBAAV,EAA4B,KAAKuB,cAAjC;;IACA,KAAKqF,SAAL;;IACA,KAAK5G,IAAL,CAAU,SAAV,EAAqBX,OAArB;EACH;;EACgB,MAAXwH,WAAW,CAACjG,KAAD,EAAQ;IACrB,OAAO,IAAInB,OAAJ,CAAY,CAACC,OAAD,EAAUoH,MAAV,KAAqB;MACpC,MAAM/F,KAAN,CAAYH,KAAZ,EAAmBnE,KAAK,IAAI;QACxB,IAAIA,KAAJ,EAAW;UACPqK,MAAM,CAACrK,KAAD,CAAN;UACA;QACH;;QACDiD,OAAO;MACV,CAND;IAOH,CARM,CAAP;EASH;;EACDkH,SAAS,GAAG;IACR;IACA,MAAM;MAAEhK;IAAF,IAAW,KAAKvC,OAAtB;IACA,MAAM0M,cAAc,GAAG,KAAKnL,YAAL,CAAkB8B,MAAlB,KAA6B,CAA7B,GAAiC,IAAjC,GAAwC,KAAKF,QAAL,IAAiB,IAAhF;;IACA,IAAIxF,EAAE,CAAC6E,UAAH,CAAcD,IAAd,CAAJ,EAAyB;MACrBA,IAAI,CAAC8E,IAAL,CAAUqF,cAAV;IACH,CAFD,MAGK,IAAI/O,EAAE,CAACgP,SAAH,CAAapK,IAAb,KAAsB5E,EAAE,CAACiP,cAAH,CAAkBrK,IAAlB,CAA1B,EAAmD;MACpD,CAAC,YAAY;QACT,IAAI;UACA,WAAW,MAAMgE,KAAjB,IAA0BhE,IAA1B,EAAgC;YAC5B,MAAM,KAAKiK,WAAL,CAAiBjG,KAAjB,CAAN;UACH;;UACD,MAAMO,GAAN;QACH,CALD,CAMA,OAAO1E,KAAP,EAAc;UACV,KAAKM,YAAL,CAAkBN,KAAlB;QACH;MACJ,CAVD;IAWH,CAZI,MAaA,IAAI,CAACzE,EAAE,CAACyJ,SAAH,CAAa7E,IAAb,CAAL,EAAyB;MAC1B,KAAKoE,aAAL,CAAmBpE,IAAnB,EAAyB6E,SAAzB,EAAoC,MAAM,CAAG,CAA7C;;MACAsF,cAAc,CAAC5F,GAAf;IACH,CAHI,MAIA,IAAI,KAAKhG,eAAL,IAAwB,KAAK6K,OAAjC,EAA0C;MAC3Ce,cAAc,CAAC5F,GAAf;IACH;EACJ;;EACD+F,aAAa,CAACR,KAAD,EAAQ;IACjB,IAAI,CAAC5M,cAAc,CAACuI,GAAf,CAAmBqE,KAAnB,CAAL,EAAgC;MAC5B,MAAMS,gBAAgB,GAAG,IAAIvP,gBAAJ,CAAsB,CAACwP,cAAD,EAAiBC,OAAjB,KAA6B;QACxE,MAAMC,MAAM,GAAGF,cAAc,CAAC5J,QAAf,CAAwB4J,cAAxB,EAAwCC,OAAxC,CAAf,CADwE,CAExE;;;QACA,IAAIrP,EAAE,CAACwM,OAAH,CAAW8C,MAAX,CAAJ,EAAwB;UACpB;UACA;UACA;UACA;UACAA,MAAM,CAACxK,IAAP,GAAc,CAACX,KAAD,EAAQkL,OAAR,KAAoB;YAC9B,IAAIlL,KAAK,KAAK,OAAd,EAAuB;cACnB,CAAC,YAAY;gBACT,IAAI;kBACA,MAAMmL,MAAN;gBACH,CAFD,CAGA,OAAO7K,KAAP,EAAc;kBACV4K,OAAO,CAAC5K,KAAD,CAAP;gBACH;cACJ,CAPD;YAQH,CATD,MAUK,IAAIN,KAAK,KAAK,OAAd,EAAuB;cACxB;cACA;cACA,CAAC,YAAY;gBACT,IAAI;kBACA,MAAMkD,OAAO,GAAI,MAAMiI,MAAvB;kBACAjI,OAAO,CAACvC,IAAR,CAAa,OAAb,EAAsBuK,OAAtB;gBACH,CAHD,CAIA,MAAM,CAAG;cACZ,CAND;YAOH,CAVI,MAWA;cACD;cACA,MAAM,IAAIhL,KAAJ,CAAW,gCAA+BF,KAAM,EAAhD,CAAN;YACH;;YACD,OAAOmL,MAAP;UACH,CA3BD;QA4BH;;QACD,OAAOA,MAAP;MACH,CAtCwB,EAsCrBZ,KAtCqB,CAAzB;MAuCA5M,cAAc,CAACyN,GAAf,CAAmBb,KAAnB,EAA0BS,gBAAgB,CAAC9H,OAAjB,EAA1B;IACH;EACJ;;EAC4B,MAAvBmI,uBAAuB,CAACpN,GAAD,EAAMC,OAAN,EAAe;IACxC,OAAO,IAAIoF,OAAJ,CAAY,CAACC,OAAD,EAAUoH,MAAV,KAAqB;MACpC;MACArM,MAAM,CAACyB,MAAP,CAAc7B,OAAd,EAAuB1B,YAAY,CAACyB,GAAD,CAAnC;MACA,IAAIiF,OAAJ,CAHoC,CAIpC;;MACA,MAAMoI,YAAY,GAAG3N,cAAc,CAAC4N,GAAf,CAAmBrN,OAAO,CAACqM,KAA3B,EAAkCrM,OAAlC,EAA2C,MAAOsD,QAAP,IAAoB;QAChFA,QAAQ,CAACgK,cAAT,CAAwBpN,WAAxB,GAAsC,KAAtC;;QACA,IAAI8E,OAAJ,EAAa;UACT,MAAMuI,GAAG,GAAG,MAAM;YACd,IAAIjK,QAAQ,CAACkK,GAAb,EAAkB;cACdlK,QAAQ,CAACmK,QAAT,GAAoBnK,QAAQ,CAACkK,GAAT,CAAaE,GAAb,CAAiBD,QAArC;YACH;UACJ,CAJD;;UAKAnK,QAAQ,CAACqK,mBAAT,CAA6B,KAA7B,EAAoCJ,GAApC;UACAA,GAAG;UACH,CAAC,MAAMvI,OAAP,EAAgBW,IAAhB,CAAqB,mBAArB,EAA0CrC,QAA1C;QACH;;QACD+B,OAAO,CAAC/B,QAAD,CAAP;MACH,CAboB,CAArB;MAcA8J,YAAY,CAAC3K,IAAb,CAAkB,OAAlB,EAA2BgK,MAA3B;MACAW,YAAY,CAAC3K,IAAb,CAAkB,SAAlB,EAA6B,MAAOmL,gBAAP,IAA4B;QACrD5I,OAAO,GAAG4I,gBAAV;QACAvI,OAAO,CAACL,OAAD,CAAP;MACH,CAHD;IAIH,CAxBM,CAAP;EAyBH;;EACiB,MAAZ9B,YAAY,GAAG;IACjB,MAAM;MAAElD;IAAF,IAAc,IAApB;IACA,MAAM;MAAE4B,OAAF;MAAWyJ,QAAX;MAAqBC;IAArB,IAAkCtL,OAAxC;IACA,MAAM6J,SAAS,GAAG7J,OAAO,CAAC6J,SAA1B;;IACA,KAAK,MAAMgC,GAAX,IAAkBjK,OAAlB,EAA2B;MACvB,IAAIjE,EAAE,CAACyJ,SAAH,CAAaxF,OAAO,CAACiK,GAAD,CAApB,CAAJ,EAAgC;QAC5B;QACA,OAAOjK,OAAO,CAACiK,GAAD,CAAd;MACH,CAHD,MAIK,IAAIlO,EAAE,CAACkQ,KAAH,CAASjM,OAAO,CAACiK,GAAD,CAAhB,CAAJ,EAA4B;QAC7B,MAAM,IAAI3J,SAAJ,CAAe,yDAAwD2J,GAAI,WAA3E,CAAN;MACH;IACJ;;IACD,IAAI7L,OAAO,CAAC+I,UAAR,IAAsBpL,EAAE,CAACyJ,SAAH,CAAaxF,OAAO,CAAC,iBAAD,CAApB,CAA1B,EAAoE;MAChEA,OAAO,CAAC,iBAAD,CAAP,GAA6BzC,cAAc,GAAG,mBAAH,GAAyB,eAApE;IACH;;IACD,IAAIkM,QAAQ,IAAIC,QAAhB,EAA0B;MACtB,MAAMwC,WAAW,GAAG9Q,MAAM,CAAC8N,IAAP,CAAa,GAAEO,QAAS,IAAGC,QAAS,EAApC,EAAuCpH,QAAvC,CAAgD,QAAhD,CAApB;MACAtC,OAAO,CAACwJ,aAAR,GAAyB,SAAQ0C,WAAY,EAA7C;IACH,CAnBgB,CAoBjB;;;IACA,IAAIjE,SAAJ,EAAe;MACX,MAAMkE,YAAY,GAAG,MAAMlE,SAAS,CAACmE,eAAV,CAA0BhO,OAAO,CAACD,GAAR,CAAYmE,QAAZ,EAA1B,CAA3B;;MACA,IAAIvG,EAAE,CAACsQ,cAAH,CAAkBF,YAAlB,CAAJ,EAAqC;QACjCnM,OAAO,CAACuJ,MAAR,GAAiB4C,YAAjB;MACH;IACJ,CA1BgB,CA2BjB;;;IACA/N,OAAO,CAACiC,SAAR,GAAoB,EAApB;IACA,IAAI+C,OAAJ;;IACA,KAAK,MAAMQ,IAAX,IAAmBxF,OAAO,CAACyF,KAAR,CAAcyI,aAAjC,EAAgD;MAC5C;MACA,MAAMjB,MAAM,GAAG,MAAMzH,IAAI,CAACxF,OAAD,CAAzB;;MACA,IAAI,CAACrC,EAAE,CAACyJ,SAAH,CAAa6F,MAAb,CAAL,EAA2B;QACvB;QACAjI,OAAO,GAAG,MAAMiI,MAAhB;;QACA;MACH;IACJ;;IACD,IAAI,CAACjI,OAAL,EAAc;MACVA,OAAO,GAAGhF,OAAO,CAACmO,kBAAR,EAAV;IACH;;IACD,MAAMpO,GAAG,GAAGC,OAAO,CAACD,GAApB;IACA,KAAKqO,eAAL,GAAuBpO,OAAO,CAACqO,0BAAR,EAAvB;;IACA,IAAIrO,OAAO,CAACqM,KAAZ,EAAmB;MACf,KAAK+B,eAAL,CAAqBjL,QAArB,GAAgC6B,OAAhC;MACA,KAAKoJ,eAAL,CAAqB/B,KAArB,GAA6BrM,OAAO,CAACqM,KAArC;MACA,KAAK+B,eAAL,CAAqB7L,IAArB,GAA4BvC,OAAO,CAACuC,IAApC;;MACA,KAAKsK,aAAL,CAAmB7M,OAAO,CAACqM,KAA3B;IACH,CAjDgB,CAkDjB;;;IACA,MAAMiC,EAAE,GAAGtO,OAAO,CAACqM,KAAR,GAAgB,KAAKc,uBAArB,GAA+CnI,OAA1D;;IACA,IAAI;MACA;MACA;MACA,IAAIuJ,iBAAiB,GAAGD,EAAE,CAACvO,GAAD,EAAM,KAAKqO,eAAX,CAA1B;;MACA,IAAIzQ,EAAE,CAACwM,OAAH,CAAWoE,iBAAX,CAAJ,EAAmC;QAC/BA,iBAAiB,GAAG,MAAMA,iBAA1B;MACH,CAND,CAOA;;;MACA,IAAI5Q,EAAE,CAACyJ,SAAH,CAAamH,iBAAb,CAAJ,EAAqC;QACjCA,iBAAiB,GAAGvO,OAAO,CAACwO,0BAAR,GAAqCzO,GAArC,EAA0C,KAAKqO,eAA/C,CAApB;;QACA,IAAIzQ,EAAE,CAACwM,OAAH,CAAWoE,iBAAX,CAAJ,EAAmC;UAC/BA,iBAAiB,GAAG,MAAMA,iBAA1B;QACH;MACJ;;MACD,IAAI5P,eAAe,CAAC4P,iBAAD,CAAnB,EAAwC;QACpC,KAAKrC,UAAL,CAAgBqC,iBAAhB;MACH,CAFD,MAGK,IAAI,KAAK/N,QAAT,EAAmB;QACpB,KAAKiC,IAAL,CAAU,QAAV,EAAoB,MAAM;UACtB,KAAK,KAAKwJ,WAAL,CAAiBsC,iBAAjB,CAAL;QACH,CAFD;;QAGA,KAAKhC,SAAL;MACH,CALI,MAMA;QACD,KAAK,KAAKN,WAAL,CAAiBsC,iBAAjB,CAAL;MACH;IACJ,CA1BD,CA2BA,OAAOnM,KAAP,EAAc;MACV,IAAIA,KAAK,YAAY3E,mBAArB,EAA0C;QACtC,MAAM,IAAID,UAAJ,CAAe4E,KAAf,EAAsB,IAAtB,CAAN;MACH;;MACD,MAAMA,KAAN;IACH;EACJ;;EACW,MAAN+C,MAAM,CAAC/C,KAAD,EAAQ;IAChB,IAAI;MACA,IAAIA,KAAK,YAAYpD,SAAjB,IAA8B,CAAC,KAAKgB,OAAL,CAAayL,eAAhD,EAAiE,CAC7D;QACA;QACA;MACH,CAJD,MAKK;QACD,KAAK,MAAMjG,IAAX,IAAmB,KAAKxF,OAAL,CAAayF,KAAb,CAAmBgJ,WAAtC,EAAmD;UAC/C;UACArM,KAAK,GAAG,MAAMoD,IAAI,CAACpD,KAAD,CAAlB;QACH;MACJ;IACJ,CAZD,CAaA,OAAO8C,MAAP,EAAe;MACX9C,KAAK,GAAG,IAAIvD,YAAJ,CAAiBqG,MAAM,CAACzB,OAAxB,EAAiCyB,MAAjC,EAAyC,IAAzC,CAAR;IACH;;IACD,KAAK5C,OAAL,CAAaF,KAAb;EACH;;EACDuE,aAAa,CAACJ,KAAD,EAAQC,QAAR,EAAkBC,QAAlB,EAA4B;IACrC,IAAI,CAAC,KAAKtD,QAAN,IAAkB,KAAKA,QAAL,CAAcF,SAApC,EAA+C;MAC3C;MACA;IACH;;IACD,KAAKE,QAAL,CAAcuD,KAAd,CAAoBH,KAApB,EAA2BC,QAA3B,EAAsCpE,KAAD,IAAW;MAC5C;MACA,IAAI,CAACA,KAAD,IAAU,CAAC,KAAKe,QAAL,CAAcF,SAA7B,EAAwC;QACpC,KAAKtC,aAAL,IAAsB3D,MAAM,CAAC0R,UAAP,CAAkBnI,KAAlB,EAAyBC,QAAzB,CAAtB;QACA,MAAMN,QAAQ,GAAG,KAAKgB,cAAtB;;QACA,IAAIhB,QAAQ,CAACE,OAAT,GAAmB,CAAvB,EAA0B;UACtB,KAAKT,IAAL,CAAU,gBAAV,EAA4BO,QAA5B;QACH;MACJ;;MACDO,QAAQ,CAACrE,KAAD,CAAR;IACH,CAVD;EAWH;EACD;AACJ;AACA;;;EACU,IAAFkH,EAAE,GAAG;IACL,OAAO,KAAKzF,MAAL,EAAa8K,aAApB;EACH;EACD;AACJ;AACA;;;EACiB,IAAT9F,SAAS,GAAG;IACZ,OAAO,KAAKvH,QAAZ;EACH;;EACS,IAANuC,MAAM,GAAG;IACT,OAAO,KAAKV,QAAL,EAAeU,MAAf,IAAyBuD,SAAhC;EACH;EACD;AACJ;AACA;;;EACwB,IAAhBjB,gBAAgB,GAAG;IACnB,IAAIC,OAAJ;;IACA,IAAI,KAAKqD,aAAT,EAAwB;MACpBrD,OAAO,GAAG,KAAK1F,eAAL,GAAuB,KAAK+I,aAAtC;IACH,CAFD,MAGK,IAAI,KAAKA,aAAL,KAAuB,KAAK/I,eAAhC,EAAiD;MAClD0F,OAAO,GAAG,CAAV;IACH,CAFI,MAGA;MACDA,OAAO,GAAG,CAAV;IACH;;IACD,OAAO;MACHA,OADG;MAEHwI,WAAW,EAAE,KAAKlO,eAFf;MAGHmO,KAAK,EAAE,KAAKpF;IAHT,CAAP;EAKH;EACD;AACJ;AACA;;;EACsB,IAAdvC,cAAc,GAAG;IACjB,IAAId,OAAJ;;IACA,IAAI,KAAKa,SAAT,EAAoB;MAChBb,OAAO,GAAG,KAAKzF,aAAL,GAAqB,KAAKsG,SAApC;IACH,CAFD,MAGK,IAAI,KAAKA,SAAL,KAAmB,KAAKtG,aAA5B,EAA2C;MAC5CyF,OAAO,GAAG,CAAV;IACH,CAFI,MAGA;MACDA,OAAO,GAAG,CAAV;IACH;;IACD,OAAO;MACHA,OADG;MAEHwI,WAAW,EAAE,KAAKjO,aAFf;MAGHkO,KAAK,EAAE,KAAK5H;IAHT,CAAP;EAKH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAIe,IAAPqF,OAAO,GAAG;IACV,OAAO,KAAKnJ,QAAL,EAAemJ,OAAtB;EACH;EACD;AACJ;AACA;;;EACmB,IAAXlD,WAAW,GAAG;IACd,OAAO,KAAKI,YAAZ;EACH;;EACe,IAAZsF,YAAY,GAAG;IACf,OAAO,KAAK3L,QAAL,EAAe2L,YAAtB;EACH;;AA/jCuC"},"metadata":{},"sourceType":"module"}